<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo修改默认显示宽度]]></title>
    <url>%2F2019%2F05%2F01%2FHexo%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[背景在我们安装完next主题后，默认的界面宽度比较窄。这时可以选择手动修改样式，增加默认显示宽度。 步骤1.首先在next主题的_config文件上查看Schemes对应的是哪个主题。 2.打开themes\next\source\css_schemes\Gemini\index.styl文件，在最底部增加如下代码。123456789101112131415161718192021222324252627282930313233header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 3.上面两步完成后，hexo clean，hexo g，hexo d。刷新界面即可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何下载安装Xshell及Xftp]]></title>
    <url>%2F2019%2F03%2F15%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[一、官网 https://www.netsarang.com/zh/xshell/ 二、找到下图对应的下载按钮，分别下载xshell、xftp 三、如果是个人使用，点击“免费授权页面”。 四、在打开的界面中，填写姓名和一个用于接收软件下载链接的邮箱，完毕点击下载。 五、过一会，就会收到邮件。 六、打开邮件，点击下图标红链接，就会自动在浏览器下载软件了。 （可以先下载xshell，再xftp，操作步骤一致。）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>xshell</tag>
        <tag>xftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tar、jar、war包区别]]></title>
    <url>%2F2019%2F02%2F02%2Ftar%E3%80%81jar%E3%80%81war%E5%8C%85%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言:在部署包的时候，经常会看到很多类型的包，其中常见的有tar包、jar包、war包等，那么这三种类型的包有什么区别？ 区别：tar包：linux打包工具生成的包通常用tar作为后缀，tar包不一定有压缩，其实可以压缩，也可以不压缩，例如xxx.tar.gz，就表示这个tar包是压缩的，并且使用的压缩算法是GNU ZIP，而xxx.tar.bz2就表示这个包使用了bzip2算法进行压缩，当然这样的命名只是一种惯例，并非强制。简单地说，linux下的tar命令就仅是打包。 jar包：Java Archive，Java编译好之后生成的class文件的包，由于直接发布这些class文件不是很方便，所以就会把许多的class文件打包成一个jar，jar中除了class文件还可以包括一些资源和配置文件，通常一个jar包就是一个java程序或者一个java库。 war包：Web application Archive，与jar基本相同，但它通常表示这是一个Java的Web应用程序的包，tomcat这种Servlet容器会认出war包并自动部署。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tar</tag>
        <tag>jar</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot+Jpa+MySql 常用配置及请求]]></title>
    <url>%2F2019%2F01%2F26%2FSpringBoot%2BJpa%2BMySql%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[关于这篇文章，介绍SpringBoot常用的配置和请求处理。大致分成三个部分介绍：常用的请求方式、Jpa配置、MySql配置。 常用的请求方式如下是常用的几种请求方式：get请求：一般用于查询数据，获取一些非重要性的信息。post请求：一般用于插入数据。put请求：一般用于数据更新。delete请求：一般用于数据删除。 那么，在SpringBoot中，怎么对这些请求方式进行处理。（这里以最常用的get、post请求为例，其他的类似） get请求：1234567891011121314151617181920//get请求，获取url路径上的参数 @PathVariable//注：localhost：8080/test/11/hans@RequestMapping(value = &quot;/test/&#123;id&#125;/&#123;name&#125;&quot;, method = RequestMethod.GET)public String sayHello(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;name&quot;) String name) &#123; return &quot;id:&quot; + id + &quot; name:&quot; + name;&#125;//get请求，获取url请求参数的值 @RequestParam//localhost:8080/test?id=99@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)public String sayHello(@RequestParam Integer id) &#123; return &quot;id:&quot; + id;&#125;//get请求，获取url请求参数的值，增加参数映射，默认值 @RequestParam//required=false 表示url中可以无id参数，此时就使用默认参数@RequestMapping(value = &quot;/test2&quot;, method = RequestMethod.GET)public String sayHello2(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;1&quot;) Integer id) &#123; return &quot;id:&quot; + id;&#125; post请求：12345678910111213141516171819202122232425//post请求//表单参数@RequestMapping(value= &quot;/getMessage&quot;, method = RequestMethod.POST)public String getMessage(int code, String message) &#123; return &quot;success&quot;;&#125;//post请求//json raw参数@PostMapping(value= &quot;/getMessageBody&quot;)public String getMessagePost(@RequestBody HolidayEntity bean) &#123; return &quot;success&quot;;&#125;//匹配参数//password如果匹配对，@RequestParam不写都okpublic void login(@RequestParam(&quot;account&quot;) String name, @RequestParam String password) &#123; System.out.println(name + &quot;:&quot; + password);&#125;//@RequestHeader注解用来将请求头的内容绑定到方法参数上。@PostMapping(value = &quot;login&quot;)public void login2(@RequestHeader(&quot;access_token&quot;) String accessToken,@RequestParam String name) &#123; System.out.println(&quot;accessToken:&quot; + accessToken);&#125; 补充：12345组合注解(RequestMapping的变形)@GetMapping = @RequestMapping(method = RequestMethod.GET)@PostMapping = @RequestMapping(method = RequestMethod.POST)@PutMapping = @RequestMapping(method = RequestMethod.PUT)@DeleteMapping = @RequestMapping(method = RequestMethod.DELETE) Jpa配置1.pom文件加入Jpa配置12345&lt;!--jpa--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 2.Application入口类增加@EnableJpaRepositories注解12@EnableJpaRepositoriespublic class Application extends SpringBootServletInitializer &#123; 3.dao接口1234567@Repositorypublic interface HolidayRepository extends JpaRepository&lt;HolidayEntity, Long&gt; &#123; @Query(value = &quot;SELECT p FROM HolidayEntity p&quot;) List&lt;HolidayEntity&gt; queryHoliday();&#125; 4.entity类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Entity@Table(name = &quot;holiday_scheme&quot;)@EntityListeners(AuditingEntityListener.class)public class HolidayEntity extends AbstractPersistable&lt;Long&gt; &#123; @Column(name = &quot;date&quot;) public String date; @Column(name = &quot;hour&quot;) public String hour; @Column(name = &quot;holiday&quot;) public String holiday; @Column(name = &quot;holiday_explain&quot;) public String holiday_explain; @Column(name = &quot;type&quot;) public String type;//SUB假期，ADD调休 public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getHour() &#123; return hour; &#125; public void setHour(String hour) &#123; this.hour = hour; &#125; public String getHoliday() &#123; return holiday; &#125; public void setHoliday(String holiday) &#123; this.holiday = holiday; &#125; public String getHoliday_explain() &#123; return holiday_explain; &#125; public void setHoliday_explain(String holiday_explain) &#123; this.holiday_explain = holiday_explain; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; @Override public String toString() &#123; return &quot;HolidayEntity&#123;&quot; + &quot;date=&apos;&quot; + date + &apos;\&apos;&apos; + &quot;, hour=&apos;&quot; + hour + &apos;\&apos;&apos; + &quot;, holiday=&apos;&quot; + holiday + &apos;\&apos;&apos; + &quot;, holiday_explain=&apos;&quot; + holiday_explain + &apos;\&apos;&apos; + &quot;, type=&apos;&quot; + type + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 5.执行，获取数据12345678@Autowiredprivate HolidayRepository holidayRepository;@RequestMapping(&quot;/test&quot;)@ResponseBodypublic List&lt;HolidayEntity&gt; test() &#123; return holidayRepository.findAll();&#125; MySql配置1.pom文件加入MySql配置12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; 2.application.properties文件配置MySql相关12345678910111213141516# tomcat配置server.port=8090# 数据库配置#Mysql属性配置文件,Spring-boot系统配置spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://*.*.*.*:3306/db?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=Asia/Shanghaispring.datasource.username=***spring.datasource.password=***#配置自动建表：updata:没有表新建，有表更新操作,控制台显示建表语句#spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect#如下的配置会导致报错 Unable to build Hibernate SessionFactory#spring.jpa.properties.hibernate.hbm2ddl.auto=validate 目录导航源码]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps概念、关键问题、工具链及文化等详细介绍]]></title>
    <url>%2F2019%2F01%2F24%2FDevOps%E6%A6%82%E5%BF%B5%E3%80%81%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E3%80%81%E5%B7%A5%E5%85%B7%E9%93%BE%E5%8F%8A%E6%96%87%E5%8C%96%E7%AD%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言（转，有修改）目前在国外，互联网巨头如Google、Facebook、Amazon、LinkedIn、Netflix、Airbnb，传统软件公司如Adobe、IBM、Microsoft、SAP等，亦或是网络业务非核心企业如苹果、沃尔玛、索尼影视娱乐、星巴克等都在采用DevOps或提供相关支持产品。那么DevOps究竟是怎样一回事？ 1.DevOps是什么？从哪里来？1.1 DevOps的概念DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。 DevOps概念早先升温于2009年的欧洲，因传统模式的运维之痛而生。 DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。 换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了下面这个DevOps能力图，良好的闭环可以大大增加整体的产出。 1.2 历史变革由上所述，相信大家对DevOps有了一定的了解。但是除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。 DevOps早在九年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。 2.DevOps的几个关键问题2.1 好处是什么？DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。 与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。 DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。 快速部署同时提高IT稳定性。这难道不矛盾吗？快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。 因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机。 3.为什么DevOps会兴起？3.1 为什么会继续火下去？条件成熟：技术配套发展技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。 来自市场的外部需求：这世界变化太快IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。 DevOps 2016年度报告给出了一个运维成本的计算公式：停机费用成本 = 部署频率 版本迭代失败概率 平均修复时间 * 断电的金钱损失 来自团队的内在动力：工程师也需要对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。 工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it） 4.实现DevOps需要什么？4.1 硬性要求：工具上的准备上文提到了工具链的打通，那么工具自然就需要做好准备。现将工具类型及对应的不完全列举整理如下： 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion 构建工具：Ant、Gradle、maven 自动部署：Capistrano、CodeDeploy 持续集成（CI）：Bamboo、Hudson、Jenkins 配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail 容器：Docker、LXC、第三方厂商如AWS 编排：Kubernetes、Core、Apache Mesos、DC/OS 服务注册与发现：Zookeeper、etcd、Consul 脚本语言：python、ruby、shell 日志管理：ELK、Logentries 系统监控：Datadog、Graphite、Icinga、Nagios zabbix 性能监控：AppDynamics、New Relic、Splunk 压力测试：JMeter、Blaze Meter、loader.io 预警：PagerDuty、pingdom、厂商自带如AWS SNS HTTP加速器：Varnish 消息总线：ActiveMQ、SQS 应用服务器：Tomcat、JBoss Web服务器：Apache、Nginx、IIS 数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库 项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker 在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers） 4.2 软性需求：文化和人DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。 出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。 这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。 5.DevOps的采用现状哪些公司在用？DevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。 那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。 他们怎么实施的？首先，大企业正在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 其次，在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。 并且调查还发现不到半数（43%）的公司在使用诸如Chef、Puppet、Ansible或Salt等配置工具；然而使用配置工具的公司更有可能同时使用多个工具。25%的受访者使用两种或更多配置工具，只使用一种工具的比例为18%。其中Chef和Puppet是最常用的组合：使用Chef的组织中有67%同时也使用Puppet，类似的，使用Puppet的组织中也有67%同时使用了Chef。 參考]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jira因你而变的项目协同管理工具]]></title>
    <url>%2F2019%2F01%2F23%2FJira%E5%9B%A0%E4%BD%A0%E8%80%8C%E5%8F%98%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[JIRA简介（转，有修改）JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。JIRA中配置灵活、功能全面、部署简单、扩展丰富。 选择JIRA理由全世界115个国家的20，000个团队已经在使用JIRA。为什么这么多国家都在用JIRA? 因为JIRA让他们的团队更高效地计划，更流畅地交流，更快捷地完成工作。在了解JIRA怎么让沟通变简单之前，让我们看看是什么让合作变麻烦的。 发展让事情变复杂! 发展是一件好事，它让想法能够不断优化、进入市场。发展同时也让事情变得更复杂，因为公司文化和工作流程并不总能跟上您企业发展的规模。扩大规模不只是企业市场的事情，究其核心，扩大规模应该是说在企业文化和工作流程上进行投资，使得企业不至于因为规模的扩大而散架。总而言之，都是为了确保你的团队和你的想法能够持续发展，勇往直前。让我们定义几个术语： 增益：整个组织从它的工具和过程中得到的好处摩擦：组织的工具和流程带来的沮丧，焦虑和麻烦因子净增益：增益减摩擦 任何过程中都会有摩擦存在，但关键是最大限度地提高净增益。当你从一开始就尽量减少摩擦，企业就可以有更好的发展。 一个想法，开始于一个人。 伟大的思想往往只开始于一个人。随着想法的进展，你开始面对一系列任务和一个不可避免的问题：如何管理一系列工作？当你一个人工作的时候，创建一个简单的问题清单就可以轻松管理你的工作流程：你只需要创建一个小的任务列表，或一个简单的Excel任务列表，添加新任务，划掉已完成的任务，很简单，对不对？ 两个人的时候，麻烦开始出现了。 接着另一人加入了，你俩合作形成了一个小组！现在本来一个人工作的流程要扩大到符合两个人共同工作：你可以通过会议手动同步你的任务清单，或者使用共享的Excel电子表格。即使表格任务清单再精细，比起独自工作，耗费的时间肯定要更多，所谓“更多的摩擦”。但因为两个人干的事情确实比一个人多，所以你就这样下去了。 更多的人，更多的摩擦。 当你开始将更多人加到这个项目中，你就开始头疼了。每加一个新人，管理这个项目就更难，因为小规模任务管理系统，没法符合更大的团队的要求。让我们来看看困扰这些成长中的组织的一些常见问题。 Excel从来不是分享型的 在共享文件服务器上托管一个Excel电子表格不是最具协作性的选项。毫无疑问：Excel是一个伟大的工具，在Atlassian我们每天都使用它。可是它确实不是一个适合大团队的任务管理解决方案。由多人分别编辑副本，修改根本没法同步进行。项目经理需要一个个分别添加修改内容，才能顾及到每个人的更新，这是浪费大家的时间。 电子邮件从来不是最清晰最准确的 通过电子邮件发送任务列表只能导致烂摊子：任务列表中的重复部分让人头疼，每复制一次源文件，工作的同步性就会差一点。本来就像重新分配一个任务这样的事情是最最简单的，现在因为有不同版本，到头来大家可能做的是重复的事情，重复从来不是一件好事情。 查看工作历史记录是一种痛苦 有效率的项目经理看历史数据来理解如何推动未来的业绩。要做到这一点吧，人们需要一个能够帮助他们有效估计过去表现的工具。历史跟踪功能有限的工具，使它很难得到正确的数据，来有效地计划未来。 那么，JIRA如何才能帮到我呢？ JIRA减少摩擦提升效率的根本保证是，你的项目只有一个主本，但每个人都可以对它进行修改。你可以使用灵活的工作流程来管理项目下的每一个工作任务。因为JIRA的核心就是要共享，所以每个人都可以更新之后，跟踪整个项目的状态。让我们来看看JIRA优于其他任务管理解决方案的秘密武器吧。 每个问题有明确的故责任，所以整个团队的分工是明确的。需要改变工作任务？每次重新分配问题，JIRA会自动通知新的负责人。 JIRA与你公司的员工名单服务器集成，所以它很容易上手。没有工作方式完全相同的两个团队。 JIRA可配置的工作流引擎捕捉恰到好处地提供最适合你团队的工作结构。 项目经理可以浏览项目的全部历史进程，以更有效地规划未来的工作。 在一个地方跟踪一切。通过电子邮件苦苦查找工作状态更新的日子再也不会有了。 JIRA的灵活的面板让即时更新状态这个曾经的麻烦事儿变成最最简单的小事情。 JIRA使团队发展更容易 如今领先的团队都在使用Scrum和看板这样的敏捷工作流进行工作。 JIRA让您迁移到敏捷的过程更加容易; 只需添加GreenHopper到你的JIRA，你会在拥有世界级问题跟踪软件的同时，立即享受到敏捷的全部好处。 开始正确了，发展就有保证了 随着你公司的成长，你只需要添加更多用户到你已有的许可证即可。 JIRA既提供云服务，又可以在你自己的主机上下载托管，灵活的选择满足你的各种需求。 安迈JIRA文档（您为什么会选择JIRA？）参考]]></content>
      <categories>
        <category>JIRA</category>
      </categories>
      <tags>
        <tag>jira</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加页面点击爆炸效果]]></title>
    <url>%2F2019%2F01%2F21%2FHexo%E6%B7%BB%E5%8A%A0%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[关于为了增加用户访问博客的趣味性，我们可以在页面上，添加页面点击的效果。如：点击爆炸效果，增加用户的交互触感。 具体操作1.创建爆炸js文件\在/themes/next/source/js/src下新建文件fireworks.js，并复制粘贴如下代码。1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 2.修改_layout.swig\在\themes\next\layout_layout.swig文件的标签最后添加： 3.主题配置文件新增如下内容12# Fireworksfireworks: true 4.部署发布，点击界面即可看到爆炸效果。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加页面点击爱心效果]]></title>
    <url>%2F2019%2F01%2F21%2FHexo%E6%B7%BB%E5%8A%A0%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[关于为了增加用户访问博客的趣味性，我们可以在页面上，添加页面点击的效果。如：爱心效果，增加用户的交互触感。 具体操作1.创建爱心js文件在/themes/next/source/js/src下新建文件love.js，并复制粘贴如下代码。1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2.修改_layout.swig在\themes\next\layout_layout.swig文件的标签最后添加：12&lt;!-- 页面点击小红心，在末尾添加，避免找不到 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 3.部署发布，点击界面即可看到爱心效果。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot介绍及常用的搭建方式]]></title>
    <url>%2F2019%2F01%2F21%2FSpringBoot%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[SpringBoot简介Spring Boot是Spring社区发布的一个开源项目，旨在帮助开发者快速并且更简单的构建项目。它使用习惯优于配置的理念让你的项目快速运行起来，使用Spring Boot很容易创建一个独立运行（运行jar，内置Servlet容器，Tomcat、jetty）、准生产级别的基于Spring框架的项目，使用SpringBoot你可以不用或者只需要很少的配置文件。 SpringBoot核心功能 独立运行的Spring项目：可以以jar包形式独立运行，通过java -jar xx.jar即可运行。 内嵌Servlet容器：可以选择内嵌Tomcat、Jetty等。 提供starter简化maven配置：一个maven项目，使用了spring-boot-starter-web时，会自动加载Spring Boot的依赖包。 自动配置Spring：Spring。 Boot会根据在类路径中的jar包、类，为jar包中的类自动配置Bean。 准生产的应用监控：提供基于http、ssh、telnet对运行时的项目进行监控。 无代码生成和xml配置：主要通过条件注解来实现。 SpringBoot项目搭建这里使用maven进行项目搭建，有几种搭建方式1、http://start.spring.io/，填写相关的项目信息、jdk版本等，就会生成一个maven项目的压缩包，下载解压导入IDE就可以。 2、IDE下直接创建，推荐使用STS(Spring Tool Suite)、IntelliJ IDEA均支持直接搭建，STS是Spring基于eclipse进行二次开发的工具。 Spring Tool Suite ：新建Spring Initializr项目,填写项目信息和选择技术，将项目设置成maven项目。 IntelliJ IDEA：新建Spring Starter project,填写项目信息和选择技术完成maven工程创建。 3、Spring Boot CLI工具，使用命令创建。 4、手工构建maven项目任意IDE新建空maven项目修改pom.xml添加Spring Boot的父级依赖Spring-boot-starter-parent，添加之后这个项目就是一个Spring Boot项目了。 项目搭建案例案例一：通过IDE直接生成SpringBoot项目1.Create New Project 新建项目 2.选择新建Spring Initializr项目 3.填入Group和Artifact 4.默认Core即可 5.Finish，即创建完毕SpringBoot项目 6.最终效果如下 案例二：手工构建maven项目并通过修改pom.xml，增加SpringBoot配置，进而使得项目变成SpringBoot项目 1.创建Maven项目 2.填入Group和Artifact 3.Finish，创建完毕Maven项目 4.修改Maven项目pom.xml文件，添加SpringBoot配置 &lt;project标签下，增加父级依赖Spring-boot-starter-parent123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 补充：Spring-boot-starter-parent是一个特殊的starter，用来提供相关的maven默认依赖，使用之后，常用的包依赖可以省略version标签。 5.增加web支持123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 6.增加编译插件12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 6.新建SpringbootApplication类，并加入@SpringBootApplication注解，代表开启Spring Boot自动配置12345678910111213@RestController@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125; @RequestMapping(&quot;/&quot;) String index()&#123; return &quot;Hello My Spring Boot Demo&quot;; &#125;&#125; 7.测试效果启动项目，浏览器输入http://localhost:8080]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot邮件发送css样式在手机邮件中显示失效问题]]></title>
    <url>%2F2019%2F01%2F19%2FSpringBoot%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81css%E6%A0%B7%E5%BC%8F%E5%9C%A8%E6%89%8B%E6%9C%BA%E9%82%AE%E4%BB%B6%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于下面分享一个本人在开发邮件服务遇到的一个小插曲，在使用SpringBoot的邮件发送FreeMarker模板时，发现在模板上设置的style样式，在手机端邮件显示部分会失效，例如字体颜色的样式失效等。针对这种情况，这里分享一下我的一个处理方式，仅供参考，不一定是最佳的解决方式。 具体步骤1.注释掉顶部style的与颜色相关的样式，测试貌似宽度，居中这些生效。 2.在具体需要设置颜色的table、tr或者tb中，直接设置style样式。这样子，在手机上显示，颜色等就生效了。 小结由于公司工作，平时工作通知沟通，都是会通过电脑的outlook邮件。电脑端上的outlook对style样式支持比较好，无需上面的处理能正常显示，只是同样的做法在手机端显示支持就显得不友好，样式没生效。凡是遇到这种样式不生效的情况，可以尝试直接在需要设置样式的地方，如tr或tb上，直接设置样式，多测试几次。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo增加APlayer音乐播放功能]]></title>
    <url>%2F2019%2F01%2F13%2FHexo%E5%A2%9E%E5%8A%A0APlayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于在个人的站点上，如果有音乐播放的功能，那么读者可以一遍阅读文章，一边欣赏音乐，是一件很愉快的事情。下面就以本站点为案例，分享增加音乐播放功能的步骤。 具体操作1.先上效果图 2.准备APlayer，下载github压缩包，解压后把dist文件夹复制到\themes\next\source目录中。 在dist目录里，新建music.js文件，并把如下代码粘贴进去。12345678910111213141516171819202122232425262728293031const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;你一定要幸福&quot;, artist: &apos;简弘亦&apos;, url: &apos;http://www.ytmp3.cn/down/51689.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/52.jpg&apos;, &#125;, &#123; name: &apos;一百万个可能(Live)&apos;, artist: &apos;摩登兄弟&apos;, url: &apos;http://www.ytmp3.cn/down/52772.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/53.jpg&apos;, &#125;, &#123; name: &apos;The Rose&apos;, artist: &apos;Westlife&apos;, url: &apos;http://www.ytmp3.cn/down/56694.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/51.jpg&apos;, &#125;, &#123; name: &apos;In The Eyes&apos;, artist: &apos;江映东&apos;, url: &apos;http://www.ytmp3.cn/down/53053.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/10.jpg&apos;, &#125; ]&#125;); 3.在\themes\next\layout_layout.swig文件中，里新增如下代码：12345&lt;!-- 音频播放 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 重新发布就可以看到效果了。 4.补充Aplayer 中文文档mp3音乐外链网站]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+DaoVoice实现网页在线通讯功能]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%2BDaoVoice%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%9C%A8%E7%BA%BF%E9%80%9A%E8%AE%AF%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于有天，你发了一篇很好的文章。你的读者看了，觉得写得很好，想要联系到你。评论留言？反馈太慢！找到你的关于简介，发邮件联系你？路径太长！现在DaoVoice就可以解决这个痛点，及时在线通讯，直接联系到作者。有问题或者咨询，可以第一时间得到反馈。并且DaoVoice现在打通了微信端，在网页上发送的消息，会直接推送到作者的微信上，另有小程序支持消息回复等，非常方便。 具体操作1.注册DaoVoice首先在DaoVoice官网上注册一个账号。注意：这里邮箱的填写要留心，我第一次填写的是QQ邮箱，不知道怎么回事，在登录的时候一直提示说邮箱验证失败，然后登录进去后，界面很奇怪简单，一直找不到应用设置，也就是没有appid。后来我换了新浪邮箱，就可以了，登录成功后，后面界面上出现了应用设置。 2.获取appid注册成功后，第一次登录，会弹出一个窗口，填完相关信息后。点击应用设置，点击安装到网站，然后就可以找到我们需要的appid了。 3.配置hexo在next主题的配置文件中（\themes\next\ _config.yml），新增如下内容：123# Online contactdaovoice: truedaovoice_app_id: 这里替换成你DaoVoice上的appid 在\themes\next\layout\ _partials\head.swig文件的最后，新增如下内容：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 4.如下就是最终配置完成的效果。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo在界面的右上角增加fork me on github]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E5%9C%A8%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8F%B3%E4%B8%8A%E8%A7%92%E5%A2%9E%E5%8A%A0fork%20me%20on%20github%2F</url>
    <content type="text"><![CDATA[关于有时候，我们在自己的站点发布了文章，有些文章内容指向的源码开源在github上。这个时候，如果在我们的站点能有一个明显且快速链接的入口，岂不快哉。 具体操作1.首先选择右上角显示的样式，在样式1列表或者样式2列表中，复制一段你喜欢的样式源码。例如我选择的就是：1&lt;a href=&quot;https://github.com/huangweicai&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 2.把上面复制的源码粘贴到\themes\next\layout_layout.swig文件的div class=”headband”下面即可。注意：href指向的地址需要修改成想要设置的github地址。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用不蒜子统计功能失效问题解决]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E4%BD%BF%E7%94%A8%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[关于比较早的时候使用next主题，想要开启站点统计功能（访客、总访问量），只需要找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但是近期，大概是2018年10月份左右，这个不蒜子的统计功能就失效了。查阅了不蒜子官方的说法， “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 具体操作1.找到原来不蒜子的域名文件，并替换掉旧的域名。文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2.注意：_config.yml配置文件busuanzi_count是需要打开的。我这里是已经开启过了，只是域名失效了而已。如果默认没有打开，可以参考如下配置。配置文件路径：\themes\next_config.yml1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 page_pv_footer:]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo增加搜索功能]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于随着时间的推移，个人站点的博客文章会越来越多，那怎么样才能快速找到你印象中的文章呢？增加一个站点内的搜索功能是非常有必要和方便的。 具体操作1.安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：1npm install hexo-generator-searchdb --save 2.全局配置文件_config.yml，新增如下内容：12345search: path: search.xml field: post format: html limit: 10000 3.hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql多表关联查询]]></title>
    <url>%2F2019%2F01%2F11%2Fsql%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[关于有时候，我们查询数据时，会采用多数据库关联查询的方式。数据库通过连接两张表或多张表查询时，会生成一张临时的中间表，然后返回给用户的就是这张临时表的数据。那么具体怎么操作呢？我们可以采用left join，搭配on、where来实现。 具体备注：1.on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。2.where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。12SELECT * FROM table1 a LEFT JOIN table2 b ON a.Sid = b.Sid WHERE a.Sname=&quot;小明&quot;Select * from aaa a left join bbb b on a.id = b.id and b.name = &apos;111111111&apos;; 个人案例：选用两表中部分字段1234567891011SELECT a.project_id AS 项目id, b.before_time AS 统计的结束时间, b.valid_row_count AS 行数, b.add_row_count AS 增加行数, b.delete_row_count AS 删除行数 FROM gitlog_project_app a LEFT JOIN gitlog_detail b ON a.id = b.project_app_id order by project_id desc]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>关联查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html复杂表格]]></title>
    <url>%2F2019%2F01%2F10%2Fhtml%E5%A4%8D%E6%9D%82%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[关于有时候，我们在做web界面显示的时候，经常遇到html复杂表格的编写。主要就是跨列，跨行等。下面分享一个既有跨列又有跨行的复杂表格样例。 具体内容1.界面效果 2.html代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;复杂表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;table width = &quot;60%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;跨两行两列&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;跨两列&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格21&lt;/td&gt; &lt;td&gt;单元格22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格31&lt;/td&gt; &lt;td&gt;单元格32&lt;/td&gt; &lt;td&gt;单元格33&lt;/td&gt; &lt;td&gt;单元格34&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格41&lt;/td&gt; &lt;td&gt;单元格42&lt;/td&gt; &lt;td&gt;单元格43&lt;/td&gt; &lt;td&gt;单元格44&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot+Jpa多数据源配置]]></title>
    <url>%2F2019%2F01%2F08%2FSpringBoot%2BJpa%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于有时候，随着业务的发展，项目关联的数据来源会变得越来越复杂，使用的数据库会比较分散，这个时候就会采用多数据源的方式来获取数据。另外，多数据源也有其他好处，例如分布式数据库的读写分离，集成多种数据库等等。下面分享我在实际项目中配置多数据源的案例。 步骤1.application.yml文件中，配置数据库源。这里primary是主库，secondary是从库。123456789101112131415161718192021222324252627server: port: 8089# 多数据源配置#primaryspring: primary: datasource: url: jdbc:mysql://127.0.0.1:3306/database1?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai username: root password: ****** driver-class-name: com.mysql.jdbc.Driver #secondary secondary: datasource: url: jdbc:mysql://127.0.0.1:3306/database1?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai username: root password: ****** driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: primary-dialect: org.hibernate.dialect.MySQL5Dialect secondary-dialect: org.hibernate.dialect.MySQL5Dialect open-in-view: true show-sql: true 2.创建一个Spring配置类，其中spring.primary.datasource的路径参考yml文件的配置。12345678910111213141516171819@Configurationpublic class DataSourceConfig &#123; @Bean(name = &quot;primaryDataSource&quot;) @Qualifier(&quot;primaryDataSource&quot;) @ConfigurationProperties(prefix=&quot;spring.primary.datasource&quot;) public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = &quot;secondaryDataSource&quot;) @Qualifier(&quot;secondaryDataSource&quot;) @Primary @ConfigurationProperties(prefix=&quot;spring.secondary.datasource&quot;) public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125;&#125; 3.分别创建主库、从库的配置类。注意：entity包和dao包的配置，以及@Primary注解指定主库。 主库配置类：123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactoryPrimary&quot;, transactionManagerRef = &quot;transactionManagerPrimary&quot;, basePackages = &#123;&quot;com.xxx.xxx.dao.primary&quot;&#125;) //设置Repository所在位置public class PrimaryConfig &#123; @Autowired private JpaProperties jpaProperties; @Autowired @Qualifier(&quot;primaryDataSource&quot;) private DataSource primaryDataSource; @Primary @Bean(name = &quot;entityManagerPrimary&quot;) public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactoryPrimary(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = &quot;entityManagerFactoryPrimary&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(primaryDataSource) .properties(getVendorProperties(primaryDataSource)) .packages(&quot;com.infinitus.yunxiao_data.entity.primary&quot;) //设置实体类所在位置 .persistenceUnit(&quot;primaryPersistenceUnit&quot;) .build(); &#125; private Map getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Primary @Bean(name = &quot;transactionManagerPrimary&quot;) public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject()); &#125;&#125; 从库的配置类：12345678910111213141516171819202122232425262728293031323334353637383940@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactorySecondary&quot;, transactionManagerRef = &quot;transactionManagerSecondary&quot;, basePackages = &#123;&quot;com.infinitus.yunxiao_data.dao.secondary&quot;&#125;) //设置Repository所在位置public class SecondaryConfig &#123; @Autowired private JpaProperties jpaProperties; @Autowired @Qualifier(&quot;secondaryDataSource&quot;) private DataSource secondaryDataSource; @Bean(name = &quot;entityManagerSecondary&quot;) public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactorySecondary(builder).getObject().createEntityManager(); &#125; @Bean(name = &quot;entityManagerFactorySecondary&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(secondaryDataSource) .properties(getVendorProperties(secondaryDataSource)) .packages(&quot;com.xxx.xxx.entity.secondary&quot;) //设置实体类所在位置 .persistenceUnit(&quot;primaryPersistenceUnit&quot;) .build(); &#125; private Map getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Bean(name = &quot;transactionManagerSecondary&quot;) PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject()); &#125;&#125; 4.分别创建主、从库dao类。主dao：1234567@Repositorypublic interface PrimaryRepository extends JpaRepository&lt;PrimaryEntity, Long&gt; &#123; @Query(value = &quot;SELECT p FROM PrimaryEntity p&quot;) List&lt;PrimaryEntity&gt; queryList();&#125; 从dao：1234567@Repositorypublic interface SecondaryRepository extends JpaRepository&lt;SecondaryEntity, Long&gt; &#123; @Query(value = &quot;SELECT p FROM SecondaryEntity p&quot;) List&lt;SecondaryEntity&gt; queryList();&#125; 5.分别创建主、从库entity类。主entity：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Entity@Table(name = &quot;holiday_scheme&quot;)@EntityListeners(AuditingEntityListener.class)public class PrimaryEntity extends AbstractPersistable&lt;Long&gt; &#123; @Column(name = &quot;date&quot;) public String date; @Column(name = &quot;hour&quot;) public String hour; @Column(name = &quot;holiday&quot;) public String holiday; @Column(name = &quot;holiday_explain&quot;) public String holiday_explain; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getHour() &#123; return hour; &#125; public void setHour(String hour) &#123; this.hour = hour; &#125; public String getHoliday() &#123; return holiday; &#125; public void setHoliday(String holiday) &#123; this.holiday = holiday; &#125; public String getHoliday_explain() &#123; return holiday_explain; &#125; public void setHoliday_explain(String holiday_explain) &#123; this.holiday_explain = holiday_explain; &#125; @Override public String toString() &#123; return &quot;PrimaryEntity&#123;&quot; + &quot;date=&apos;&quot; + date + &apos;\&apos;&apos; + &quot;, hour=&apos;&quot; + hour + &apos;\&apos;&apos; + &quot;, holiday=&apos;&quot; + holiday + &apos;\&apos;&apos; + &quot;, holiday_explain=&apos;&quot; + holiday_explain + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 从entity：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = &quot;active_dashboards&quot;)@EntityListeners(AuditingEntityListener.class)public class SecondaryEntity extends AbstractPersistable&lt;Long&gt; &#123; @Column(name = &quot;dashboard_id&quot;) public String dashboard_id; @Column(name = &quot;user_id&quot;) public String user_id; @Column(name = &quot;order_index&quot;) public String order_index; public String getDashboard_id() &#123; return dashboard_id; &#125; public void setDashboard_id(String dashboard_id) &#123; this.dashboard_id = dashboard_id; &#125; public String getUser_id() &#123; return user_id; &#125; public void setUser_id(String user_id) &#123; this.user_id = user_id; &#125; public String getOrder_index() &#123; return order_index; &#125; public void setOrder_index(String order_index) &#123; this.order_index = order_index; &#125; @Override public String toString() &#123; return &quot;SecondaryEntity&#123;&quot; + &quot;dashboard_id=&apos;&quot; + dashboard_id + &apos;\&apos;&apos; + &quot;, user_id=&apos;&quot; + user_id + &apos;\&apos;&apos; + &quot;, order_index=&apos;&quot; + order_index + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 6.controller请求获取不同数据库的数据。1234567891011121314151617181920212223@RestController@RequestMapping(&quot;/database&quot;)public class MailController &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired PrimaryRepository primaryRepository; @Autowired SecondaryRepository secondaryRepository; @RequestMapping(&quot;/primary&quot;) @ResponseBody public String primary() &#123; return primaryRepository.queryList().toString(); &#125; @RequestMapping(&quot;/secondary&quot;) @ResponseBody public String secondary() &#123; return secondaryRepository.queryList().toString(); &#125;&#125; 注意下面提两个在配置多数据源时遇到的坑点，一不注意就掉坑了。1.Application类不需要配置@EnableJpaRepositories注解，会报如下错误。1A component required a bean named &apos;entityManagerFactory&apos; that could not be f 2.注意检查dao类，获取数据的方法上格式是否正确，有没有某个字段是表中不存在的，避免启动异常。如下，SecondaryEntity表中是不存在job_name字段的，所以注释掉才能启动成功等。12//@Query(value = &quot;SELECT p FROM SecondaryEntity p where p.job_name = ?1&quot;)//List&lt;SecondaryEntity&gt; queryOdcRecord(String job_name);]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[application.properties和application.yml文件的区别]]></title>
    <url>%2F2019%2F01%2F06%2Fapplication.properties%E5%92%8Capplication.yml%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[关于一般上来说，当我们创建一个SpringBoot项目时，IDE会默认帮我们创建一个application.properties配置文件。有些朋友习惯把.properties文件改成.yml文件。那么这两种文件类型有什么区别呢？ 区别1.内容格式比较：.properties文件，通过.来连接，通过=来赋值，结构上，没有分层的感觉，但比较直接。.yml文件，通过：来分层，结构上，有比较明显的层次感，最后key赋值的：后需要留一个空格 2.执行顺序如果工程中同时存在application.properties文件和 application.yml文件，yml文件会先加载，而后加载的properties文件会覆盖yml文件。所以建议工程中，只使用其中一种类型的文件即可。 案例application.properties：1234567server.port=8081 spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.url=jdbc:mysql://aliyuncs.com:3306/database?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=******spring.datasource.driver-class-name=com.mysql.jdbc.Driver application.yml：1234567891011server: port: 8082 spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/database username: root password: ****** type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot项目的jar包在服务器上启动的正确姿势]]></title>
    <url>%2F2019%2F01%2F06%2FSpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84jar%E5%8C%85%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%90%AF%E5%8A%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[关于一般上来说，我们在服务器上启动一个jar，最简单的方式就是java -jar xx.jar，虽然这种方式简单但有时候我们的场景需要更多，例如常驻后台运行，在命令行窗口关闭的时候不中断项目，指定端口，并且输出日志到文件中等。所以这个时候我们通常会采用脚本启动和关闭项目，方便项目的统一管理。 脚本启动和关闭的案例1.启动脚本123nohup java -jar ../webapp/xxx.jar --server.port=9002 &gt;&gt; ../logs/xxx.log &amp;tail -f ../logs/xxx.log 2.关闭脚本12345678910pid=`ps -ef|grep java|grep xxx.jar |awk &apos;&#123;print $2&#125;&apos;`if [ -z $pid ]; then echo &apos;app not runing&apos;else echo &apos;kill pid &apos; $pid kill $pid sleep 5 ps -ef|grep javafi 3.最后一步，执行脚本。（cd到脚本目录并执行）1sh xxx.sh 补充1.命令后加&amp;符号，可以使命令在后台执行。2.tail -f 实时查看日志文件。3.如果要先关闭项目再启动，尽量不要使用Ctrl+z退出命令行窗口的当前状态，最好新开一个命令行窗口，然后执行关闭脚本，再执行启动脚本。这样操作，可以避免应用莫名其妙没有关闭到的情况，反复执行关闭脚本却没有杀死应用进程的奇怪问题，需要杀多次。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VB宏程序，实现换行追加"\\"符号]]></title>
    <url>%2F2018%2F12%2F31%2FVB%E5%AE%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%8D%A2%E8%A1%8C%E8%BF%BD%E5%8A%A0%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[关于有这样一个场景，有一次，公司一个同事说，excel表格中，想在每行换行的地方追加”\\“符号，以便该excel表格在导入jira系统的时候，该符号会被系统识别为换行符，方便阅读。于是乎有了下面的研究成果。 完整的vb宏程序1.打开vb宏编辑窗口，可使用快捷键Alt+F11打开，然后粘贴下面程序。下面的代码可以实现，在你选择的区域，运行宏，则该区域上，凡是换行符的位置都会追加上”\\“符号。123456789101112131415161718192021222324252627282930313233Sub AppendToSpritOnEnterRight()Dim c As RangeDim StaR As StringDim posStr As StringDim i As LongDim resultStr, cacheStr As StringDim lastI As LongFor Each c In Selection StaR = c.Value posStr = &quot;&quot; cacheStr = &quot;&quot; resultStr = &quot;&quot; lastI = 0 For i = 1 To Len(StaR) posStr = Mid(StaR, i, 1) If posStr = Chr(10) Then &apos;拼接字符串\\ cacheStr = Mid(StaR, lastI + 1, i - 1 - lastI) &amp; &quot;\\&quot; &amp; Chr(10) resultStr = resultStr + cacheStr lastI = i //MsgBox resultStr End If Next i cacheStr = Mid(StaR, lastI + 1, Len(StaR) - lastI) resultStr = resultStr + cacheStr c.Value = resultStrNextEnd Sub 2.补充几点常用快捷键：Alt+Entry：换行Alt+F11：打开程序窗口F5：打开运行宏窗口 函数：Mid(String,start[,Length])String - 必需的参数。输入从中返回指定数量的字符的字符串。Start - 必需的参数。 一个整数，它指定了字符串的起始位置。Length - 必需的参数。 一个整数，指定要返回的字符数。注意：Start需要从1开始。]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>excel</tag>
        <tag>vb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持公司电脑不锁屏技巧]]></title>
    <url>%2F2018%2F12%2F30%2F%E4%BF%9D%E6%8C%81%E5%85%AC%E5%8F%B8%E7%94%B5%E8%84%91%E4%B8%8D%E9%94%81%E5%B1%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[关于我们在公司上班，一般网络及设备监管比较好的公司，会对发配给你的电脑进行定时锁屏，好保护公司资料。但是这也很不方便，例如有些时间需要电脑开着，远程连接电脑的办公时，电脑锁屏了，就无法使用例如TeamViewer这样的工具连接进来。下面介绍一个我亲测有效的小技巧，有需要的朋友可以试试。 具体操作1.在电脑上，新建一个html页面，并把下面的代码复制进去。执行的原理就是，通过模拟电脑的物理按键，定时触发，从而模拟人在操作电脑的行为。这样子，电脑就不会锁屏了。123456789101112131415&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;I need you still work!&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor=&quot;#215E21&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function PressKey()&#123; var objWs = new ActiveXObject(&quot;Wscript.Shell&quot;); objWs.SendKeys(&quot;&#123;SCROLLLOCK&#125;&quot;); &#125; setInterval(&quot;PressKey()&quot;,10000);//按下按键的间隔时间。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.一定要使用IE浏览器打开，使用其他浏览器可能会因为安全问题无法执行成功。在IE浏览器打开后，会弹两次框，都选择允许就行了。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>不锁屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot工程打包]]></title>
    <url>%2F2018%2F12%2F30%2FSpringBoot%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[关于在SpringBoot的应用里，最方便的莫过于可以直接把工程打成一个jar/war包，由于内嵌了tomcat，所以可以直接在服务器上启动。而SpringBoot适合前后端分离，所以建议打jar包，在服务器上，通过java -jar xx.jar即可启动。 打包流程1.在pom文件中添加打包插件12345678910111213141516171819202122&lt;!-- 打包spring boot应用 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--配置入口--&gt; &lt;mainClass&gt;com.aaa.bbb.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.Application入口类继承SpringBootServletInitializer抽象类，并实现configure方法。12345678public class Application extends SpringBootServletInitializer &#123; //springboot打包需要@Overrideprotected SpringApplicationBuilder configure( SpringApplicationBuilder builder) &#123; return builder.sources(this.getClass());&#125; 3.执行打包操作在Intellij的最右边点击Maven Project，依次操作，先clean，再install。 4.操作完毕后，下面就是SpringBoot打出来的jar包了，快放到服务器上试试吧。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio发布项目到Jcenter仓库步骤]]></title>
    <url>%2F2018%2F10%2F21%2FAndroid%20Studio%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0Jcenter%E4%BB%93%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前言Android Studio中把项目的lib库提交到Jcenter仓库中，需要使用到Bintray，Bintray是jCenter的提供商，他支持上传lib到多个平台，jCenter只是众多平台中的一个，形象的说jCenter是位于某地的仓库，Bintray是送货的卡车，你写的库就是货了。 注册准备1.在Bintray上注册账号，并创建package。注册bintray，注意：注册时尽量使用国外的邮箱，避免接收不到验证码。例如我使用雅虎邮箱。 2.完成注册之后，登录网站，然后点击maven。 3.点击Add New Package，为我们的library创建一个新的package。 4.假设你已经注册账你并按照上面步骤操作，或者使用我提供的账号，登陆成功后会出现如下界面，点击maven进入该仓库，并点击Add New Package创建新的包。 5.填写package相关信息，如下： Android Studio配置部分6.操作AS项目，配置相关信息，命令行操作lib包上传。Android Studio安装上传Bintray插件和填写相关信息：（下面选用我测试通过并且操作路径最短的方式）在项目的根build文件中补充如下标红内容这是根build源文件：123456789101112131415161718192021222324252627// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123;google()jcenter()&#125;dependencies &#123;classpath &apos;com.android.tools.build:gradle:3.1.3&apos; classpath &apos;com.novoda:bintray-release:+&apos; // 新增// NOTE: Do not place your application dependencies here; they belong// in the individual module build.gradle files &#125;&#125;allprojects &#123;repositories &#123;google()jcenter()&#125; tasks.withType(Javadoc) &#123; // 新增 options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;) options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)&#125;&#125;task clean(type: Delete) &#123;delete rootProject.buildDir&#125; 7.然后在lib的build文件中补充如下内容：这是lib的源build文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071`apply plugin: ``&apos;com.android.library&apos;``apply plugin: ``&apos;com.novoda.bintray-release&apos;` `// 新增``android &#123;``compileSdkVersion ``28``defaultConfig &#123;``minSdkVersion ``15``targetSdkVersion ``28``versionCode ``2``versionName ``&quot;1.0.2&quot;``testInstrumentationRunner ``&quot;android.support.test.runner.AndroidJUnitRunner&quot;``&#125;``buildTypes &#123;``release &#123;``minifyEnabled ``false``proguardFiles getDefaultProguardFile(``&apos;proguard-android.txt&apos;``), ``&apos;proguard-rules.pro&apos;``&#125;``&#125;``lintOptions &#123; ``// 新增``abortOnError ``false``&#125;``&#125;``dependencies &#123;``implementation fileTree(dir: ``&apos;libs&apos;``, include: [``&apos;*.jar&apos;``])``implementation ``&apos;com.android.support:appcompat-v7:28.0.0-rc02&apos;``testImplementation ``&apos;junit:junit:4.12&apos;``androidTestImplementation ``&apos;com.android.support.test:runner:1.0.2&apos;``androidTestImplementation ``&apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;``&#125;``publish &#123; ``// 新增``userOrg = ``&apos;huangweicai&apos;` `// 注册bintray时的username``groupId = ``&apos;com.infinitus_demo_lib&apos;` `// 项目包名``artifactId = ``&apos;infinitus_demo_lib&apos;` `// 项目名``publishVersion = ``&apos;1.0.2&apos;` `// 发布版本号``desc = ``&apos;Summarize the tools or methods commonly used in routine development&apos;` `// 项目描述，可选项``website = ``&apos;[https://github.com/huangweicai/infinitus_demo_lib&apos;](https://github.com/huangweicai/infinitus_demo_lib&apos;)` `// 项目站点，可选项``&#125;` 8.在Android Studio的命令行窗口依次输入如下命令：123gradlew generatePomFileForReleasePublicationgradlew publishReleasePublicationToMavenLocalgradlew bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxx -PdryRun=false 其中，PbintrayUser是Bintray的用户名，PbintrayKey是Bintray的API Key。（API Key在注册成功后，可以在修改信息的界面找到，最好在第一次注册成功后就记录好）等待执行，看到BUILD SUCCESSFUL说明上传Bintray成功。 9.进入Bintray，可以找到我们上传的包，在页面的左下角看到maven地址说明上传内容正确，第一次在页面的右下角会看到add to jcenter，需要我们手动点击一下这个add to jcenter按钮，然后等待lib包审核通过后，我们就可以引用jcenter上的包了。以上就是Android Studio打包上传到Jcenter的完整流程。 最后测试AS引入implementation ‘com.infinitus_demo_lib:infinitus_demo_lib:1.0.2’，代码中调用演示工具类TestUtil.test(context);查看吐司是否提示，提示成功说明已经成功发布并引入jcenter包。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>jcenter</tag>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令小结]]></title>
    <url>%2F2018%2F10%2F11%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言平时我们经常使用到git，有些朋友喜欢使用git的窗口界面来操作，我个人也蛮喜欢的。不过git命令是学习git的根本，和机器打交道最近的方式，所以学好git对理解git的工作流是很有帮助的。下面梳理一下本人常用的git操作命令。 正文git提交操作流程（进入到项目目录中，然后执行如下命令）＃初始化本地仓库git init＃将本地内容添加至git索引中（注意：每次提交最好都执行一下）git add . （git add –all）＃将索引添加至本地仓库中（日志log，注意新增文件内容需要该命令才能提交到本地仓库，才能push到远程）git commit -m “first commit” 注意：日志不能为空字符串等 #添加远程仓库路径git remote add origin ssh://git@git.infinitus.com.cn:7999/han/gittestdemo.git＃将本地内容push至远程仓库中git push -u origin master（push之前，确保公钥已经放上去了） 子分支与主分支master合并流程1.首先我们在子分支上开发，完成后提交代码到子分支git add .git commit -m ‘dev’git push -u origin dev2.把分支的代码合并到主分支master上步骤一览：先切换到master上，保险起见先拉取一下远程仓库master，然后再在合master的主分支上合并dev分支，最后把合并成的master分支提交到远程仓库。git checkout mastergit pull origin master (同是master分支，pull回来就会自动本地merge)git merge devgit push origin master补充：1.git status可以查看状态2.远程仓库有子分支，也不可以直接拉取子分支，先拉取主分支再切换到子分支3.git hook 在使用git窗口操作，git base命令窗口不会打印内容。4.注意，本地commit的时候存在冲突的情况，即使git push成功，但远程并没有更新到内容。需要把冲突去掉再次重新操作流程。git add . git commit git push···5.pull master回来时，如果远程仓库没有t1之类的子分支，则本地git branch -a是看不到该子分支的。该命令只是看本地仓库的分支信息。 git常用命令＃查看本地分支git branch＃查看远程分支（好像也包含本地分支）git branch -a＃创建本地分支，并切换到分支（test是分支名称，可替换）git branch testgit checkout test注：也可以一次性写法git checkout -b dev＃提交到远程仓库1.git push origin test:remoteTest 本地test分支提交到远程remoteTest分支（如果远程没有则新建该分支）2.git push origin test 本地test分支提交到远程test分支（如果远程没有则新建该分支）（push操作，就算当前分支是test1，也可以直接把test2 push到远程，再push test1都ok）＃从远程拉取分支git pull origin test:test注：如果不写本地分支名称，则默认和远程分支同名，这时命令为：$ git pull origin test 注意：1.操作git的过程中，在子分支test1中git branch testMerge分支，发现子分支还可以拉取子子分支，test1与testMerge内容一样。 ＃clone远程仓库到指定目录git clone ssh://git@git.infinitus.com.cn:7999/han/gittestdemo.git “E:\git_workplace\newdemo”（注意：目录需要用””包起来）cd E: ＃git 删除本地分支git branch -d br＃git 删除远程分支（删除分支与提交分支类似，区别就是在分支名前加上:）git push origin :br (origin 后面有空格) git代码库回滚: 指的是将代码库某分支退回到以前的某个commit id【本地代码库回滚】：git reset –hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除git reset –hard HEAD~3：将最近3次的提交回滚 git配置信息相关查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址：git config –global user.name “xxxx”git config –global user.email “xxxx” 查看公钥：cat ~/.ssh/id_rsa.pub]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效代码行数预研方案]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%9C%89%E6%95%88%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E9%A2%84%E7%A0%94%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言公司这边其实已经使用sonar对代码进行了统计，但需求想要更加明确的统计每个user单独的代码量，以便对该user的工作质量进行评估。sonar目前只有对整个目录文件的代码行数统计，对于git merge之类的代码没有区别得很细，也就是说不断merge别人的代码也会被统计到当前提交的user上，而我们是需要明确每个user具体提交了多少代码量，然后下面是针对有效代码行数预研的方案及试错，有需要的朋友可以参阅，少走弯路。 已实现:提交通过的代码可以用sonar统计行数。Num2-Num1=有效行数（实际开发行数）存在问题：如果过程中分支有从别的分支合并代码过来，会造成统计时混合了其他分支代码。 处理方案方案一：（客户端方案）1.情况一，当前功能分支一直提交，并没有merge其他分支来支持当前分支开发，那么可以通过每次提交成功后统计该分支的有效行数，通过之前已实现的sonar方案。2.情况二，f2分支在开发过程中，如需要引用f1分支的功能作为开发支撑，这种情况需要在客户端的git仓库中埋点，使用git hook（post-merge）监听，当pull f1并merge成功后，触发post-merge监听，接着执行通知，告知接收者几个关键参数（合并的分支、合并成功后总代码行数），接收者收到入参后，接着统计合并分支的代码行数，然后 合并后的总行数-当前统计分支行数=合并进来的行数，以后每次f1分支提交统计代码行数时，都减去“合并进来的行数”得到提交的有效行数。 方案二：（服务端方案）拉取分支后，云效在未合并完成前，不允许拉取合并其他分支。监听用户的在服务端的post-receive触发，如果与第一次拉取做一个对应关系。 方案三：（本地客户端hook，优化版本）本地客户端方案关键点：hook脚本注入，本地代码统计方案，merge、commit触发执行脚本，shell脚本post交互（实现全局hook，本质也是本地配置引用，需要配置干预。与直接copy都是需要人为本地干预 no）1.hook脚本注入：hook文件自动copy暂时没有触发入口（方案：云效流程干预）2.shell脚本post交互：云效上有sonar数据的拦截处理层，这部分之前是我们自己处理，api交互补充逻辑即可。方案步骤：1.拉取分支，然后给一个勾选的触发，弹窗，选择远程的hook和本地仓库目录（目录/.git/hooks）在云效这里，由于客户端pull动作无法知道完成时机，要么云效定时循环检测目录存在，然后注入远程hook，要么培训说明人为判断拉取成功后必须手动勾选，然后注入远程hook，两个方式目的都是想办法把远程的hooks文件注入到本地的hooks目录中。2.本地代码统计（难点，在不安转三方支持的情况下，怎么统计分支除merge之外的纯代码量，暂时只统计新增行）那么考虑能否从文件本身的角度入手，监听或合适时机主动获取文件数量和文件总行数。把过程中产生纯新增行数记录到并合适时机告诉接收者。3.shell通过curl发送post请求：curl -d parm1=111&amp;param2=222 http://www.baidu.com4.本地每次merge与本地commit只有hook存在，都能触发对应的脚本程序。 实验情况：1.测试本地存在hook脚本的情况，在本地分支merge和commit两个关键动作都能触发执行脚本。本地提交，成功触发pre-commit脚本：本地分支merge，成功触发post-merge脚本： 2.测试目录文件数及总行数：获取本地仓库目录下，所有文件书和行数：shell脚本测试ok补充：1）能否去除空行，注释行。（使用grep排除空行和注释行，sed和tee用法）2）缓存对比数据方案（本地？远程？）3）test.sh在统计文件数和行数，不包括.git目录的。执行结果：3.测试修改文件了，先merge再commit，确定行数获取时机。答：merge之前，git的操作是必须需要先本地commit当前分支，否则合并失败。（保证当前分支是最新的节点）这里就解决了，统计merge之前和merge之后的代码行数。统一由commit时产生的行数作为计算基准数。当前分支未commit就执行merge动作：当前分支已commit，执行merge动作，触发脚本计算行数： 方案四：服务器端，分析.git，分离每个user提交的代码信息，分别获取对应的行数。（选用方案）脚本代码：统计总行数、历史删除、增加的总行数1git log --author=&quot;hans&quot; --pretty=tformat: --numstat | gawk &apos;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;增加的行数:%s 删除的行数:%s 总行数: %s\n&quot;,add,subs,loc &#125;&apos; 注意：该方法统计，最后一行如果是空行，不纳入行数计算，如果不是则纳入。测试场景：用户hans：1.master分支有10行，在master上创建分支t1，t1分支新增5行。分别获取master行数、t1行数master行数10：t1行数15： 2.上传t1分支，让用户tt克隆项目，tt用户在master的基础上新建分支t2，新增行数8，提交。分别获取hans提交行数，tt提交行数。把t2合并进入master，再次统计master上不同用户提交的代码行数，hans行数10，tt行数8，符合预期有效行数。补充：hans电脑上传master（已合并t2），下图是tt电脑上，拉取最新的master，然后再次分别获取对应行数。对于tt用户来说，虽然master上行数变为18行，但统计tt的提交量还是8行，符合预期有效行数。3.测试同一个文件下，不同用户操作，并统计行数。在hans电脑上，如果发生冲突的部分，会导致tt用户提交的这部分冲突代码统计失败，还是原来的8行，只有hans的代码新增了，由原来的10行，新增了5行。在tt用户电脑，master上pull回来，统计同hans电脑结果。 结论：1.为了统计用户有效代码行数，建议每个用户在commit的行都是新的行，如果在别的用户行上修改，统计时是不纳入你的代码行数。2.每个分支上，用户之间提交的代码行数都是相互隔离的，可以分别获取对应用户提交的代码行数，与merge无关。3.在实际应用上，虽然shell脚本已经编写完毕，但是由于系统间在执行过程中会存在权限问题，不保证每个系统都稳定能执行到脚本。最终讨论的方案是，通过Java调用git命令来执行git的信息统计，后面会针对该内容专门开一篇文章分享。 相关资料git hooks钩子：那么钩子什么时候被执行，Git预定义了触发时机：ClientSide hooks：1 pre-commit，当执行commit动作时先执行此hook，可以用此hook做一些检查，比如代码风格检查，或者先跑测试。2 prepare-commit-msg， 当commit时需要输入message前会触发此hook，可以用此hook来定制自己的default message信息。3 commit-msg，当用户输入commit的message后被触发，可以用此hook校验message的信息，比如是否符合规定，有没有cr等。4 post-commit, 当commit完成后被触发，可以用此hook发送notification等。5 pre-rebase, rebase之前会被触发，可以用此hook来拒绝所有的已经push的commits进行rebase操作。6 post-merge, 当merge成功后，会触发此hook。7 pre-push, 当push时，remote refs被更新，但是在所有的objects传输前被触发。8 pre-auto-gc, 当git gc –auto执行前被触发。在垃圾回收之前做一些验证或备份是挺不错的。 ServerSide hooks:1 pre-receive, 当收到push动作之前会被执行。2 update, 也是收到push动作之前被执行，但是有可能被执行多次，每个branch一次。3 post-receive, 当push动作已经完成的时候会被触发，可以用此hook来push notification等，比如发邮件，通知持续构建服务器等。 git log相关信息：统计某人的代码提交量，包括增加，删除：git log –author=”$(git config –get user.name)” –pretty=tformat: –numstat | gawk ‘{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf “added lines: %s removed lines : %s total lines: %s\n”,add,subs,loc }’ -仓库提交者排名前 5（如果看全部，去掉 head 管道即可）：git log –pretty=’%aN’ | sort | uniq -c | sort -k1 -n -r | head -n 5仓库提交者（邮箱）排名前 5：这个统计可能不会太准，因为很多人有不同的邮箱，但会使用相同的名字git log –pretty=format:%ae | gawk – ‘{ ++c[$0]; } END { for(cc in c) printf “%5d %s\n”,c[cc],cc; }’ | sort -u -n -r | head -n 5贡献者统计：git log –pretty=’%aN’ | sort -u | wc -l提交数统计：git log –oneline | wc -l添加或修改的代码行数：git log –stat|perl -ne ‘END { print $c } $c += $1 if /(\d+) insertions/; git log 参数说明：–author 指定作者–stat 显示每次更新的文件修改统计信息，会列出具体文件列表–shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：–numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 例如：git log -p -2–name-only 仅在提交信息后显示已修改的文件清单–name-status 显示新增、修改、删除的文件清单–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）–graph 显示 ASCII 图形表示的分支合并历史–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式） 例如： git log –pretty=oneline ; git log –pretty=short ; git log –pretty=full ; git log –pretty=fuller–pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析 例如：git log –pretty=format:””%h - %an, %ar : %s”” 下面列出了常用的格式占位符写法及其代表的意义。 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明–since 限制显示输出的范围， 例如： git log –since=2.weeks 显示最近两周的提交 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 一些例子： // 一分钟之前的所有 git log --until=1.minute.ago //一天之内的log log git log --since=1.day.ago //一个小时之内的log git log --since=1.hour.ago //一个月之前到半个月之前的log git log --since=`.month.ago --until=2.weeks.ago //某个时间段的log git log --since ==2013-08.01 --until=2013-09-07 //看看某一个文件的相关历史记录 git blame 例如：git blame index.html --date short]]></content>
      <categories>
        <category>方案</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>shell</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题的个性化设置及评论系统的集成]]></title>
    <url>%2F2018%2F09%2F17%2FHexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[前言这篇文章是续&lt;玩Hexo博客，从搭建到百度、谷歌收录全流程&gt;的补充篇，该篇文章主要描述的是Hexo在实际的配置过程中，需要设置的点。以本博客为案例，一步步配置自己喜欢的Hexo显示。 正文修改或新增菜单打开themes/next/_config.yml 文件，搜索menu关键字，修改对应图标名称或者新增对应menu的图标。123456789101112131415menu: #首页 default home: / || home #归档 default archives: /archives/ || archive #分类 categories: /categories/ || th #标签 tags: /tags/ || tags #相册 photo_album: /photo_album/ || image #友链 friendly_link: /friendly_link/ || link #关于 about: /about/ || user 注意：1.除了home，archives , /后面都需要手动创建这个页面。2.图片对应的名称，例如link图标，可以在hexo个性化icon网站 找到。 添加头像打开 themes/next/_config.yml文件，搜索Sidebar Avatar关键字，去掉avatar 前面的#，并补充自己的头像路径。注意：头像存放路径\themes\next\source\uploads，uploads文件夹如果没有则新建，然后存放头像图片即可读取。1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/hans_icon.jpg 上下浏览当前页面时显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。12# Scroll percent label in b2t button scrollpercent: true 如果想把 top按钮放在侧边栏,打开 themes/next/_config.yml ,搜索关键字 b2t ,把 false 改为 true。12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 设置侧边栏社交链接打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。其中，图标可以根据上面菜单图标的方式替换。123456#社交连接social: GitHub: https://huangweicai.github.io/ || github 简书: https://www.jianshu.com/u/28a4d1accff3 || book Coding: http://lantianwork.coding.me/ || codiepie 知乎: https://www.zhihu.com/people/wei-c-77-91/activities || certificate 开启版权声明主题配置文件下,搜索关键字 post_copyright , enable 改为 true：12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 添加顶部加载条打开 themes/next/_config.yml ，搜索关键字 pace ,设置为 true ,可以更换加载样式：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash #替换更换样式 其他的可以参考该文章:Hexo+Next个人博客主题优化]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客，从搭建到百度、谷歌收录全流程]]></title>
    <url>%2F2018%2F09%2F17%2FHexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%BB%8E%E6%90%AD%E5%BB%BA%E5%88%B0%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言hexo静态博客很早就耳闻了，鉴于时间和精力，之前一直没决心要做一个自己的个人网站。在使用hexo搭建静态博客之前，还有一个小插曲，之前曾经考虑过使用wordpress搭建个人网站，阿里云服务器和域名都已经购买，并且已经在服务器上配置好了相关内容，但是域名备案需要服务器运行3个月，只能通过ip地址访问wordpress博客，这个点就很影响个人网站的使用，并且阿里云服务器一年的费用达到2000多，也是一笔不小的开销。综合权衡对比之后，转而投向谷歌github、百度coding的hexo静态个人网站，好处是免费并且有平台提供的特定域名地址，并且hexo可以满足目前这些所有的需要，个性化定制型强，搭配目前使用人数最多的next主题，简直是帅到不要。并且现在很多搜索到的个人博客，基本都是hexo+next主题的搭配，可见其受欢迎程度。言归正传，下面就把玩hexo从搭建到收录全过程分享给大家，很多坑点网上是找不到的，千篇一律的内容很难分析问题。 相关资料1.关键地址NexT主题官方文档 hexo的一些部署配置可以简单参看，主要看NexT主题怎么在hexo中配置，定制个性化内容。leancloud网站 博客集成阅读数，valine评论系统都需要用到。hexo个性化icon网站 里面的icon名称可以使用到hexo中，替换并定制化icon，hexo的图标都是关联到这里的。coding网站 国内存放静态博客界面代码github网站 国外存放静态博客界面代码注意：个人把静态博客分别上传到coding、github，方便国内和国外的搜索引擎爬取到内容。自己可以酌情选用。百度收录站点 提交coding域名谷歌收录站点 提交github域名 2.相关地址valine评论系统用于博客集成评论系统Node.js hexo需要先安装node.js环境Git hexo在上传时需要用到git5.1: git@github.com:iissnan/hexo-theme-next.git （个人使用版本）6.0: git@github.com:theme-next/hexo-theme-next.git 正文3.准备工作本地环境需要安装Node.js和Git，可以在上面的地址找到安装下载界面。 4.安装并初始化hexo上面两个准备工作完成后，可以选择一个目录，右键选择Git Bash Here打开终端，依次执行如下命令：（使用cmd的终端也行，不过需要配置git的环境变量，这里直接使用git自带的终端方便）1234npm install -g hexo-clihexo init Hexocd Hexonpm install 都执行成功后，会在目录生成一个Hexo文件夹，以后Hexo文件夹就是本地静态网站配合和文章存放的地方。接下来启动本地hexo，先本地预览hexo，执行如下命令：1hexo s 当看到命令行窗口出现，INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.的内容时，说明启动成功了，然后在浏览器输入网址：http://localhost:4000/ 即可看到本地hexo网站了。 另外，补充几个hexo关键的操作命令：1234hexo clean #清空hexo，主要删除Hexo根目录下的public文件夹hexo g #重新成功public文件夹内容hexo s #启动本地hexo服务hexo d #发布到远程仓库 以后每次同步远程仓库，基本都是上面的命令顺序。 5.替换默认的hexo主题（landscape–&gt;NexT）hexo默认的主题是landscape，目前NexT主题是使用最多的，个性化定制性都很好，使用NexT主题替换landscape默认主题，我们需要先把NexT主题拷贝到Hexo本地，在终端输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 拷贝成功后，使用编辑器打开Hexo根目录下的_config.yml文件，把里面的landscape主题替换成next主题，然后hexo clean，hexo g，hexo s，接着刷新浏览器就可以看到新配置的NexT主题了。1234567891011121314151617181920# Sitetitle: Hexo # 此处改为你站点的标题subtitle: # 此处改为你站点的副标题description: # 此处改为你站点的说明keywords: # 此处改为你站点的关键字author: John Doe # 此处改为你的名字language: # 此处改为 zh-CNtimezone: # 此处改为 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/ # 此处可以改为 :title/permalink_defaults:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 此处改为 next 6.上传本地博客到github或者coding把本地静态代码上传到远程仓库，如github、coding等。首先我们需要在两个平台上有账号，并且分别创建项目仓库，注意，新建的项目名称是有特定要求的，github上的名称必须是：{user_name}.github.io，coding上的名称必须是：{user_name}.coding.me，这样子上传到远程仓库的静态文件，在访问的时候才不会出现样式混乱和404问题，每个平台只提供一个这样的pages页面，而格式也是固定的，按照人家平台的规定来就行了。其中，用户名就是当时注册的时候用的是那个名称，别搞乱了，不是后面修改资料的昵称，用户名一般修改不了。 上传之前，先把ssh在本地配置一下，打开Hexo根目录下的_config.yml文件，找到deploy并如下修改：（把其中的github和coding的ssh替换成自己的就行了，注意一下，需要先在平台上配置好publickey，玩git的应该都知道）12345deploy: type: git repo: github: git@github.com:xxx/xxx.github.io.git,master coding: git@git.coding.net:xxx/xxx.coding.me.git,master 修改好了之后，执行命令，上传到远程仓库：1hexo g -d 最后，浏览器打开远程仓库地址，查看代码，然后分别把github或coding的pages打开，等待一会，然后访问pages地址就可以看到你提交的个人网站了。 7.百度、谷歌收录操作让百度、谷歌收录个人网站，需要两个平台上的验证文件放在博客的根目录下（这里选择推荐的一种验证方式）。打开上面提到的百度收录，谷歌收录的网址，统一选择文件验证的方式，百度这边的话在添加地址的时候，第一次可能需要填写个人信息，补充完毕后，添加网站，然后根据提示下一步操作即可，谷歌的也是类似。这里提一个坑点：百度、谷歌的验证方式都是使用文件验证，从平台上下载的验证文件在放根目录的说法中，网上大多数的说法都是说直接把文件放到Hexo根目录的source目录下，然后上传到远程仓库，但是实验证明这种做法是有问题的，当我们执行hexo g生成静态界面的时候，hexo会把多余的内容添加到source目录下的验证文件中，导致百度或者谷歌验证一直失败。解决方法：在hexo g操作之前，验证文件先不加入到source目录中，等待hexo g执行成功后，手动把验证文件copy到Hexo根目录下的public目录中，然后执行hexo d上传到远程仓库，最后再测试平台上的验证文件，可以看到百度、谷歌都验证成功了。最后就等待收录通过后，输入site:地址，测试一下是否搜索到博客地址。谷歌的收录速度很快，上传到仓库后几个小时就可以搜索到我的网站了，而百度则慢点，可能要一两个星期，有备案填入在百度上则会加快收录速度。 结语上面就是Hexo网站从配置到谷歌、百度收录的全过程了，另外关于Hexo的个性化配置，评论系统的配置等这些还是有很多细节和坑点，可以持续关注，晚些时间会放出关于hexo主题个性化定制的相关内容。可以以本博客显示作为参考。最后，如果在搭建hexo博客过程中，有解决不了的问题或者想让熟悉的人快速帮你配置并指导，可以添加wechat596有偿服务，添加好友时备注：昵称-hexo服务。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
