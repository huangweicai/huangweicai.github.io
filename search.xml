<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo增加APlayer音乐播放功能]]></title>
    <url>%2F2019%2F01%2F13%2FHexo%E5%A2%9E%E5%8A%A0APlayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于在个人的站点上，如果有音乐播放的功能，那么读者可以一遍阅读文章，一边欣赏音乐，是一件很愉快的事情。下面就以本站点为案例，分享增加音乐播放功能的步骤。 具体操作1.先上效果图 2.准备APlayer，下载github压缩包，解压后把dist文件夹复制到\themes\next\source目录中。 在dist目录里，新建music.js文件，并把如下代码粘贴进去。12345678910111213141516171819202122232425262728293031const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;你一定要幸福&quot;, artist: &apos;简弘亦&apos;, url: &apos;http://www.ytmp3.cn/down/51689.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/52.jpg&apos;, &#125;, &#123; name: &apos;一百万个可能(Live)&apos;, artist: &apos;摩登兄弟&apos;, url: &apos;http://www.ytmp3.cn/down/52772.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/53.jpg&apos;, &#125;, &#123; name: &apos;The Rose&apos;, artist: &apos;Westlife&apos;, url: &apos;http://www.ytmp3.cn/down/56694.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/51.jpg&apos;, &#125;, &#123; name: &apos;In The Eyes&apos;, artist: &apos;江映东&apos;, url: &apos;http://www.ytmp3.cn/down/53053.mp3&apos;, cover: &apos;http://img.ytmp3.cn/image/10.jpg&apos;, &#125; ]&#125;); 3.在\themes\next\layout_layout.swig文件中，里新增如下代码：12345&lt;!-- 音频播放 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 重新发布就可以看到效果了。 4.补充Aplayer 中文文档mp3音乐外链网站]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+DaoVoice实现网页在线通讯功能]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%2BDaoVoice%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%9C%A8%E7%BA%BF%E9%80%9A%E8%AE%AF%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于有天，你发了一篇很好的文章。你的读者看了，觉得写得很好，想要联系到你。评论留言？反馈太慢！找到你的关于简介，发邮件联系你？路径太长！现在DaoVoice就可以解决这个痛点，及时在线通讯，直接联系到作者。有问题或者咨询，可以第一时间得到反馈。并且DaoVoice现在打通了微信端，在网页上发送的消息，会直接推送到作者的微信上，另有小程序支持消息回复等，非常方便。 具体操作1.注册DaoVoice首先在DaoVoice官网上注册一个账号。注意：这里邮箱的填写要留心，我第一次填写的是QQ邮箱，不知道怎么回事，在登录的时候一直提示说邮箱验证失败，然后登录进去后，界面很奇怪简单，一直找不到应用设置，也就是没有appid。后来我换了新浪邮箱，就可以了，登录成功后，后面界面上出现了应用设置。 2.获取appid注册成功后，第一次登录，会弹出一个窗口，填完相关信息后。点击应用设置，点击安装到网站，然后就可以找到我们需要的appid了。 3.配置hexo在next主题的配置文件中（\themes\next_config.yml），新增如下内容：123# Online contactdaovoice: truedaovoice_app_id: 这里替换成你DaoVoice上的appid 在\themes\next\layout_partials\head.swig文件的最后，新增如下内容：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 4.如下就是最终配置完成的效果。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo在界面的右上角增加fork me on github]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E5%9C%A8%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8F%B3%E4%B8%8A%E8%A7%92%E5%A2%9E%E5%8A%A0fork%20me%20on%20github%2F</url>
    <content type="text"><![CDATA[关于有时候，我们在自己的站点发布了文章，有些文章内容指向的源码开源在github上。这个时候，如果在我们的站点能有一个明显且快速链接的入口，岂不快哉。 具体操作1.首先选择右上角显示的样式，在样式1列表或者样式2列表中，复制一段你喜欢的样式源码。例如我选择的就是：1&lt;a href=&quot;https://github.com/huangweicai&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 2.把上面复制的源码粘贴到\themes\next\layout_layout.swig文件的div class=”headband”下面即可。注意：href指向的地址需要修改成想要设置的github地址。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用不蒜子统计功能失效问题解决]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E4%BD%BF%E7%94%A8%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[关于比较早的时候使用next主题，想要开启站点统计功能（访客、总访问量），只需要找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但是近期，大概是2018年10月份左右，这个不蒜子的统计功能就失效了。查阅了不蒜子官方的说法， “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 具体操作1.找到原来不蒜子的域名文件，并替换掉旧的域名。文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2.注意：_config.yml配置文件busuanzi_count是需要打开的。我这里是已经开启过了，只是域名失效了而已。如果默认没有打开，可以参考如下配置。配置文件路径：\themes\next_config.yml1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 page_pv_footer:]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo增加搜索功能]]></title>
    <url>%2F2019%2F01%2F12%2FHexo%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于随着时间的推移，个人站点的博客文章会越来越多，那怎么样才能快速找到你印象中的文章呢？增加一个站点内的搜索功能是非常有必要和方便的。 具体操作1.安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：1npm install hexo-generator-searchdb --save 2.全局配置文件_config.yml，新增如下内容：12345search: path: search.xml field: post format: html limit: 10000 3.hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql多表关联查询]]></title>
    <url>%2F2019%2F01%2F11%2Fsql%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[关于有时候，我们查询数据时，会采用多数据库关联查询的方式。数据库通过连接两张表或多张表查询时，会生成一张临时的中间表，然后返回给用户的就是这张临时表的数据。那么具体怎么操作呢？我们可以采用left join，搭配on、where来实现。 具体备注：1.on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。2.where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。12SELECT * FROM table1 a LEFT JOIN table2 b ON a.Sid = b.Sid WHERE a.Sname=&quot;小明&quot;Select * from aaa a left join bbb b on a.id = b.id and b.name = &apos;111111111&apos;; 个人案例：选用两表中部分字段1234567891011SELECT a.project_id AS 项目id, b.before_time AS 统计的结束时间, b.valid_row_count AS 行数, b.add_row_count AS 增加行数, b.delete_row_count AS 删除行数 FROM gitlog_project_app a LEFT JOIN gitlog_detail b ON a.id = b.project_app_id order by project_id desc]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html复杂表格]]></title>
    <url>%2F2019%2F01%2F10%2Fhtml%E5%A4%8D%E6%9D%82%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[关于有时候，我们在做web界面显示的时候，经常遇到html复杂表格的编写。主要就是跨列，跨行等。下面分享一个既有跨列又有跨行的复杂表格样例。 具体内容1.界面效果 2.html代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;复杂表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;table width = &quot;60%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;跨两行两列&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;跨两列&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格21&lt;/td&gt; &lt;td&gt;单元格22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格31&lt;/td&gt; &lt;td&gt;单元格32&lt;/td&gt; &lt;td&gt;单元格33&lt;/td&gt; &lt;td&gt;单元格34&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格41&lt;/td&gt; &lt;td&gt;单元格42&lt;/td&gt; &lt;td&gt;单元格43&lt;/td&gt; &lt;td&gt;单元格44&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot+Jpa多数据源配置]]></title>
    <url>%2F2019%2F01%2F08%2FSpringBoot%2BJpa%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于有时候，随着业务的发展，项目关联的数据来源会变得越来越复杂，使用的数据库会比较分散，这个时候就会采用多数据源的方式来获取数据。另外，多数据源也有其他好处，例如分布式数据库的读写分离，集成多种数据库等等。下面分享我在实际项目中配置多数据源的案例。 步骤1.application.yml文件中，配置数据库源。这里primary是主库，secondary是从库。123456789101112131415161718192021222324252627server: port: 8089# 多数据源配置#primaryspring: primary: datasource: url: jdbc:mysql://127.0.0.1:3306/database1?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai username: root password: ****** driver-class-name: com.mysql.jdbc.Driver #secondary secondary: datasource: url: jdbc:mysql://127.0.0.1:3306/database1?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai username: root password: ****** driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: primary-dialect: org.hibernate.dialect.MySQL5Dialect secondary-dialect: org.hibernate.dialect.MySQL5Dialect open-in-view: true show-sql: true 2.创建一个Spring配置类，其中spring.primary.datasource的路径参考yml文件的配置。12345678910111213141516171819@Configurationpublic class DataSourceConfig &#123; @Bean(name = &quot;primaryDataSource&quot;) @Qualifier(&quot;primaryDataSource&quot;) @ConfigurationProperties(prefix=&quot;spring.primary.datasource&quot;) public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = &quot;secondaryDataSource&quot;) @Qualifier(&quot;secondaryDataSource&quot;) @Primary @ConfigurationProperties(prefix=&quot;spring.secondary.datasource&quot;) public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125;&#125; 3.分别创建主库、从库的配置类。注意：entity包和dao包的配置，以及@Primary注解指定主库。 主库配置类：123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactoryPrimary&quot;, transactionManagerRef = &quot;transactionManagerPrimary&quot;, basePackages = &#123;&quot;com.infinitus.yunxiao_data.dao.primary&quot;&#125;) //设置Repository所在位置public class PrimaryConfig &#123; @Autowired private JpaProperties jpaProperties; @Autowired @Qualifier(&quot;primaryDataSource&quot;) private DataSource primaryDataSource; @Primary @Bean(name = &quot;entityManagerPrimary&quot;) public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactoryPrimary(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = &quot;entityManagerFactoryPrimary&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(primaryDataSource) .properties(getVendorProperties(primaryDataSource)) .packages(&quot;com.infinitus.yunxiao_data.entity.primary&quot;) //设置实体类所在位置 .persistenceUnit(&quot;primaryPersistenceUnit&quot;) .build(); &#125; private Map getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Primary @Bean(name = &quot;transactionManagerPrimary&quot;) public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject()); &#125;&#125; 从库的配置类：12345678910111213141516171819202122232425262728293031323334353637383940@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactorySecondary&quot;, transactionManagerRef = &quot;transactionManagerSecondary&quot;, basePackages = &#123;&quot;com.infinitus.yunxiao_data.dao.secondary&quot;&#125;) //设置Repository所在位置public class SecondaryConfig &#123; @Autowired private JpaProperties jpaProperties; @Autowired @Qualifier(&quot;secondaryDataSource&quot;) private DataSource secondaryDataSource; @Bean(name = &quot;entityManagerSecondary&quot;) public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactorySecondary(builder).getObject().createEntityManager(); &#125; @Bean(name = &quot;entityManagerFactorySecondary&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(secondaryDataSource) .properties(getVendorProperties(secondaryDataSource)) .packages(&quot;com.infinitus.yunxiao_data.entity.secondary&quot;) //设置实体类所在位置 .persistenceUnit(&quot;primaryPersistenceUnit&quot;) .build(); &#125; private Map getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Bean(name = &quot;transactionManagerSecondary&quot;) PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject()); &#125;&#125; 4.分别创建主、从库dao类。主dao：1234567@Repositorypublic interface PrimaryRepository extends JpaRepository&lt;PrimaryEntity, Long&gt; &#123; @Query(value = &quot;SELECT p FROM PrimaryEntity p&quot;) List&lt;PrimaryEntity&gt; queryList();&#125; 从dao：1234567@Repositorypublic interface SecondaryRepository extends JpaRepository&lt;SecondaryEntity, Long&gt; &#123; @Query(value = &quot;SELECT p FROM SecondaryEntity p&quot;) List&lt;SecondaryEntity&gt; queryList();&#125; 5.分别创建主、从库entity类。主entity：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Entity@Table(name = &quot;holiday_scheme&quot;)@EntityListeners(AuditingEntityListener.class)public class PrimaryEntity extends AbstractPersistable&lt;Long&gt; &#123; @Column(name = &quot;date&quot;) public String date; @Column(name = &quot;hour&quot;) public String hour; @Column(name = &quot;holiday&quot;) public String holiday; @Column(name = &quot;holiday_explain&quot;) public String holiday_explain; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getHour() &#123; return hour; &#125; public void setHour(String hour) &#123; this.hour = hour; &#125; public String getHoliday() &#123; return holiday; &#125; public void setHoliday(String holiday) &#123; this.holiday = holiday; &#125; public String getHoliday_explain() &#123; return holiday_explain; &#125; public void setHoliday_explain(String holiday_explain) &#123; this.holiday_explain = holiday_explain; &#125; @Override public String toString() &#123; return &quot;PrimaryEntity&#123;&quot; + &quot;date=&apos;&quot; + date + &apos;\&apos;&apos; + &quot;, hour=&apos;&quot; + hour + &apos;\&apos;&apos; + &quot;, holiday=&apos;&quot; + holiday + &apos;\&apos;&apos; + &quot;, holiday_explain=&apos;&quot; + holiday_explain + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 从entity：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = &quot;active_dashboards&quot;)@EntityListeners(AuditingEntityListener.class)public class SecondaryEntity extends AbstractPersistable&lt;Long&gt; &#123; @Column(name = &quot;dashboard_id&quot;) public String dashboard_id; @Column(name = &quot;user_id&quot;) public String user_id; @Column(name = &quot;order_index&quot;) public String order_index; public String getDashboard_id() &#123; return dashboard_id; &#125; public void setDashboard_id(String dashboard_id) &#123; this.dashboard_id = dashboard_id; &#125; public String getUser_id() &#123; return user_id; &#125; public void setUser_id(String user_id) &#123; this.user_id = user_id; &#125; public String getOrder_index() &#123; return order_index; &#125; public void setOrder_index(String order_index) &#123; this.order_index = order_index; &#125; @Override public String toString() &#123; return &quot;SecondaryEntity&#123;&quot; + &quot;dashboard_id=&apos;&quot; + dashboard_id + &apos;\&apos;&apos; + &quot;, user_id=&apos;&quot; + user_id + &apos;\&apos;&apos; + &quot;, order_index=&apos;&quot; + order_index + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 6.controller请求获取不同数据库的数据。1234567891011121314151617181920212223@RestController@RequestMapping(&quot;/database&quot;)public class MailController &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired PrimaryRepository primaryRepository; @Autowired SecondaryRepository secondaryRepository; @RequestMapping(&quot;/primary&quot;) @ResponseBody public String primary() &#123; return primaryRepository.queryList().toString(); &#125; @RequestMapping(&quot;/secondary&quot;) @ResponseBody public String secondary() &#123; return secondaryRepository.queryList().toString(); &#125;&#125; 注意下面提两个在配置多数据源时遇到的坑点，一不注意就掉坑了。1.Application类不需要配置@EnableJpaRepositories注解，会报如下错误。1A component required a bean named &apos;entityManagerFactory&apos; that could not be f 2.注意检查dao类，获取数据的方法上格式是否正确，有没有某个字段是表中不存在的，避免启动异常。如下，SecondaryEntity表中是不存在job_name字段的，所以注释掉才能启动成功等。12//@Query(value = &quot;SELECT p FROM SecondaryEntity p where p.job_name = ?1&quot;)//List&lt;SecondaryEntity&gt; queryOdcRecord(String job_name);]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[application.properties和application.yml文件的区别]]></title>
    <url>%2F2019%2F01%2F06%2Fapplication.properties%E5%92%8Capplication.yml%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[关于一般上来说，当我们创建一个SpringBoot项目时，IDE会默认帮我们创建一个application.properties配置文件。有些朋友习惯把.properties文件改成.yml文件。那么这两种文件类型有什么区别呢？ 区别1.内容格式比较：.properties文件，通过.来连接，通过=来赋值，结构上，没有分层的感觉，但比较直接。.yml文件，通过：来分层，结构上，有比较明显的层次感，最后key赋值的：后需要留一个空格 2.执行顺序如果工程中同时存在application.properties文件和 application.yml文件，yml文件会先加载，而后加载的properties文件会覆盖yml文件。所以建议工程中，只使用其中一种类型的文件即可。 案例application.properties：1234567server.port=8081 spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.url=jdbc:mysql://aliyuncs.com:3306/database?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=******spring.datasource.driver-class-name=com.mysql.jdbc.Driver application.yml：1234567891011server: port: 8082 spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/database username: root password: ****** type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot项目的jar包在服务器上启动的正确姿势]]></title>
    <url>%2F2019%2F01%2F06%2FSpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84jar%E5%8C%85%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%90%AF%E5%8A%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[关于一般上来说，我们在服务器上启动一个jar，最简单的方式就是java -jar xx.jar，虽然这种方式简单但有时候我们的场景需要更多，例如常驻后台运行，在命令行窗口关闭的时候不中断项目，指定端口，并且输出日志到文件中等。所以这个时候我们通常会采用脚本启动和关闭项目，方便项目的统一管理。 脚本启动和关闭的案例1.启动脚本123nohup java -jar ../webapp/xxx.jar --server.port=9002 &gt;&gt; ../logs/xxx.log &amp;tail -f ../logs/xxx.log 2.关闭脚本12345678910pid=`ps -ef|grep java|grep xxx.jar |awk &apos;&#123;print $2&#125;&apos;`if [ -z $pid ]; then echo &apos;app not runing&apos;else echo &apos;kill pid &apos; $pid kill $pid sleep 5 ps -ef|grep javafi 3.最后一步，执行脚本。（cd到脚本目录并执行）1sh xxx.sh 补充1.命令后加&amp;符号，可以使命令在后台执行。2.tail -f 实时查看日志文件。3.如果要先关闭项目再启动，尽量不要使用Ctrl+z退出命令行窗口的当前状态，最好新开一个命令行窗口，然后执行关闭脚本，再执行启动脚本。这样操作，可以避免应用莫名其妙没有关闭到的情况，反复执行关闭脚本却没有杀死应用进程的奇怪问题，需要杀多次。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VB宏程序，实现换行追加"\\"符号]]></title>
    <url>%2F2018%2F12%2F31%2FVB%E5%AE%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%8D%A2%E8%A1%8C%E8%BF%BD%E5%8A%A0%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[关于有这样一个场景，有一次，公司一个同事说，excel表格中，想在每行换行的地方追加”\\“符号，以便该excel表格在导入jira系统的时候，该符号会被系统识别为换行符，方便阅读。于是乎有了下面的研究成果。 完整的vb宏程序1.打开vb宏编辑窗口，可使用快捷键Alt+F11打开，然后粘贴下面程序。下面的代码可以实现，在你选择的区域，运行宏，则该区域上，凡是换行符的位置都会追加上”\\“符号。123456789101112131415161718192021222324252627282930313233Sub AppendToSpritOnEnterRight()Dim c As RangeDim StaR As StringDim posStr As StringDim i As LongDim resultStr, cacheStr As StringDim lastI As LongFor Each c In Selection StaR = c.Value posStr = &quot;&quot; cacheStr = &quot;&quot; resultStr = &quot;&quot; lastI = 0 For i = 1 To Len(StaR) posStr = Mid(StaR, i, 1) If posStr = Chr(10) Then &apos;拼接字符串\\ cacheStr = Mid(StaR, lastI + 1, i - 1 - lastI) &amp; &quot;\\&quot; &amp; Chr(10) resultStr = resultStr + cacheStr lastI = i //MsgBox resultStr End If Next i cacheStr = Mid(StaR, lastI + 1, Len(StaR) - lastI) resultStr = resultStr + cacheStr c.Value = resultStrNextEnd Sub 2.补充几点常用快捷键：Alt+Entry：换行Alt+F11：打开程序窗口F5：打开运行宏窗口 函数：Mid(String,start[,Length])String - 必需的参数。输入从中返回指定数量的字符的字符串。Start - 必需的参数。 一个整数，它指定了字符串的起始位置。Length - 必需的参数。 一个整数，指定要返回的字符数。注意：Start需要从1开始。]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持公司电脑不锁屏技巧]]></title>
    <url>%2F2018%2F12%2F30%2F%E4%BF%9D%E6%8C%81%E5%85%AC%E5%8F%B8%E7%94%B5%E8%84%91%E4%B8%8D%E9%94%81%E5%B1%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[关于我们在公司上班，一般网络及设备监管比较好的公司，会对发配给你的电脑进行定时锁屏，好保护公司资料。但是这也很不方便，例如有些时间需要电脑开着，远程连接电脑的办公时，电脑锁屏了，就无法使用例如TeamViewer这样的工具连接进来。下面介绍一个我亲测有效的小技巧，有需要的朋友可以试试。 具体操作1.在电脑上，新建一个html页面，并把下面的代码复制进去。执行的原理就是，通过模拟电脑的物理按键，定时触发，从而模拟人在操作电脑的行为。这样子，电脑就不会锁屏了。123456789101112131415&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;I need you still work!&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor=&quot;#215E21&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function PressKey()&#123; var objWs = new ActiveXObject(&quot;Wscript.Shell&quot;); objWs.SendKeys(&quot;&#123;SCROLLLOCK&#125;&quot;); &#125; setInterval(&quot;PressKey()&quot;,10000);//按下按键的间隔时间。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.一定要使用IE浏览器打开，使用其他浏览器可能会因为安全问题无法执行成功。在IE浏览器打开后，会弹两次框，都选择允许就行了。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot工程打包]]></title>
    <url>%2F2018%2F12%2F30%2FSpringBoot%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[关于在SpringBoot的应用里，最方便的莫过于可以直接把工程打成一个jar/war包，由于内嵌了tomcat，所以可以直接在服务器上启动。而SpringBoot适合前后端分离，所以建议打jar包，在服务器上，通过java -jar xx.jar即可启动。 打包流程1.在pom文件中添加打包插件12345678910111213141516171819202122&lt;!-- 打包spring boot应用 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--配置入口--&gt; &lt;mainClass&gt;com.aaa.bbb.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.Application入口类继承SpringBootServletInitializer抽象类，并实现configure方法。12345678public class Application extends SpringBootServletInitializer &#123; //springboot打包需要@Overrideprotected SpringApplicationBuilder configure( SpringApplicationBuilder builder) &#123; return builder.sources(this.getClass());&#125; 3.执行打包操作在Intellij的最右边点击Maven Project，依次操作，先clean，再install。 4.操作完毕后，下面就是SpringBoot打出来的jar包了，快放到服务器上试试吧。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio发布项目到Jcenter仓库步骤]]></title>
    <url>%2F2018%2F10%2F21%2FAndroid%20Studio%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0Jcenter%E4%BB%93%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前言Android Studio中把项目的lib库提交到Jcenter仓库中，需要使用到Bintray，Bintray是jCenter的提供商，他支持上传lib到多个平台，jCenter只是众多平台中的一个，形象的说jCenter是位于某地的仓库，Bintray是送货的卡车，你写的库就是货了。 注册准备1.在Bintray上注册账号，并创建package。注册bintray，注意：注册时尽量使用国外的邮箱，避免接收不到验证码。例如我使用雅虎邮箱。 2.完成注册之后，登录网站，然后点击maven。 3.点击Add New Package，为我们的library创建一个新的package。 4.假设你已经注册账你并按照上面步骤操作，或者使用我提供的账号，登陆成功后会出现如下界面，点击maven进入该仓库，并点击Add New Package创建新的包。 5.填写package相关信息，如下： Android Studio配置部分6.操作AS项目，配置相关信息，命令行操作lib包上传。Android Studio安装上传Bintray插件和填写相关信息：（下面选用我测试通过并且操作路径最短的方式）在项目的根build文件中补充如下标红内容这是根build源文件：123456789101112131415161718192021222324252627// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123;google()jcenter()&#125;dependencies &#123;classpath &apos;com.android.tools.build:gradle:3.1.3&apos; classpath &apos;com.novoda:bintray-release:+&apos; // 新增// NOTE: Do not place your application dependencies here; they belong// in the individual module build.gradle files &#125;&#125;allprojects &#123;repositories &#123;google()jcenter()&#125; tasks.withType(Javadoc) &#123; // 新增 options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;) options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)&#125;&#125;task clean(type: Delete) &#123;delete rootProject.buildDir&#125; 7.然后在lib的build文件中补充如下内容：这是lib的源build文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071`apply plugin: ``&apos;com.android.library&apos;``apply plugin: ``&apos;com.novoda.bintray-release&apos;` `// 新增``android &#123;``compileSdkVersion ``28``defaultConfig &#123;``minSdkVersion ``15``targetSdkVersion ``28``versionCode ``2``versionName ``&quot;1.0.2&quot;``testInstrumentationRunner ``&quot;android.support.test.runner.AndroidJUnitRunner&quot;``&#125;``buildTypes &#123;``release &#123;``minifyEnabled ``false``proguardFiles getDefaultProguardFile(``&apos;proguard-android.txt&apos;``), ``&apos;proguard-rules.pro&apos;``&#125;``&#125;``lintOptions &#123; ``// 新增``abortOnError ``false``&#125;``&#125;``dependencies &#123;``implementation fileTree(dir: ``&apos;libs&apos;``, include: [``&apos;*.jar&apos;``])``implementation ``&apos;com.android.support:appcompat-v7:28.0.0-rc02&apos;``testImplementation ``&apos;junit:junit:4.12&apos;``androidTestImplementation ``&apos;com.android.support.test:runner:1.0.2&apos;``androidTestImplementation ``&apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;``&#125;``publish &#123; ``// 新增``userOrg = ``&apos;huangweicai&apos;` `// 注册bintray时的username``groupId = ``&apos;com.infinitus_demo_lib&apos;` `// 项目包名``artifactId = ``&apos;infinitus_demo_lib&apos;` `// 项目名``publishVersion = ``&apos;1.0.2&apos;` `// 发布版本号``desc = ``&apos;Summarize the tools or methods commonly used in routine development&apos;` `// 项目描述，可选项``website = ``&apos;[https://github.com/huangweicai/infinitus_demo_lib&apos;](https://github.com/huangweicai/infinitus_demo_lib&apos;)` `// 项目站点，可选项``&#125;` 8.在Android Studio的命令行窗口依次输入如下命令：123gradlew generatePomFileForReleasePublicationgradlew publishReleasePublicationToMavenLocalgradlew bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxx -PdryRun=false 其中，PbintrayUser是Bintray的用户名，PbintrayKey是Bintray的API Key。（API Key在注册成功后，可以在修改信息的界面找到，最好在第一次注册成功后就记录好）等待执行，看到BUILD SUCCESSFUL说明上传Bintray成功。 9.进入Bintray，可以找到我们上传的包，在页面的左下角看到maven地址说明上传内容正确，第一次在页面的右下角会看到add to jcenter，需要我们手动点击一下这个add to jcenter按钮，然后等待lib包审核通过后，我们就可以引用jcenter上的包了。以上就是Android Studio打包上传到Jcenter的完整流程。 最后测试AS引入implementation ‘com.infinitus_demo_lib:infinitus_demo_lib:1.0.2’，代码中调用演示工具类TestUtil.test(context);查看吐司是否提示，提示成功说明已经成功发布并引入jcenter包。]]></content>
      <tags>
        <tag>jcenter</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令小结]]></title>
    <url>%2F2018%2F10%2F11%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言平时我们经常使用到git，有些朋友喜欢使用git的窗口界面来操作，我个人也蛮喜欢的。不过git命令是学习git的根本，和机器打交道最近的方式，所以学好git对理解git的工作流是很有帮助的。下面梳理一下本人常用的git操作命令。 正文git提交操作流程（进入到项目目录中，然后执行如下命令）＃初始化本地仓库git init＃将本地内容添加至git索引中（注意：每次提交最好都执行一下）git add . （git add –all）＃将索引添加至本地仓库中（日志log，注意新增文件内容需要该命令才能提交到本地仓库，才能push到远程）git commit -m “first commit” 注意：日志不能为空字符串等 #添加远程仓库路径git remote add origin ssh://git@git.infinitus.com.cn:7999/han/gittestdemo.git＃将本地内容push至远程仓库中git push -u origin master（push之前，确保公钥已经放上去了） 子分支与主分支master合并流程1.首先我们在子分支上开发，完成后提交代码到子分支git add .git commit -m ‘dev’git push -u origin dev2.把分支的代码合并到主分支master上步骤一览：先切换到master上，保险起见先拉取一下远程仓库master，然后再在合master的主分支上合并dev分支，最后把合并成的master分支提交到远程仓库。git checkout mastergit pull origin master (同是master分支，pull回来就会自动本地merge)git merge devgit push origin master补充：1.git status可以查看状态2.远程仓库有子分支，也不可以直接拉取子分支，先拉取主分支再切换到子分支3.git hook 在使用git窗口操作，git base命令窗口不会打印内容。4.注意，本地commit的时候存在冲突的情况，即使git push成功，但远程并没有更新到内容。需要把冲突去掉再次重新操作流程。git add . git commit git push···5.pull master回来时，如果远程仓库没有t1之类的子分支，则本地git branch -a是看不到该子分支的。该命令只是看本地仓库的分支信息。 git常用命令＃查看本地分支git branch＃查看远程分支（好像也包含本地分支）git branch -a＃创建本地分支，并切换到分支（test是分支名称，可替换）git branch testgit checkout test注：也可以一次性写法git checkout -b dev＃提交到远程仓库1.git push origin test:remoteTest 本地test分支提交到远程remoteTest分支（如果远程没有则新建该分支）2.git push origin test 本地test分支提交到远程test分支（如果远程没有则新建该分支）（push操作，就算当前分支是test1，也可以直接把test2 push到远程，再push test1都ok）＃从远程拉取分支git pull origin test:test注：如果不写本地分支名称，则默认和远程分支同名，这时命令为：$ git pull origin test 注意：1.操作git的过程中，在子分支test1中git branch testMerge分支，发现子分支还可以拉取子子分支，test1与testMerge内容一样。 ＃clone远程仓库到指定目录git clone ssh://git@git.infinitus.com.cn:7999/han/gittestdemo.git “E:\git_workplace\newdemo”（注意：目录需要用””包起来）cd E: ＃git 删除本地分支git branch -d br＃git 删除远程分支（删除分支与提交分支类似，区别就是在分支名前加上:）git push origin :br (origin 后面有空格) git代码库回滚: 指的是将代码库某分支退回到以前的某个commit id【本地代码库回滚】：git reset –hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除git reset –hard HEAD~3：将最近3次的提交回滚 git配置信息相关查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址：git config –global user.name “xxxx”git config –global user.email “xxxx” 查看公钥：cat ~/.ssh/id_rsa.pub]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效代码行数预研方案]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%9C%89%E6%95%88%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E9%A2%84%E7%A0%94%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言公司这边其实已经使用sonar对代码进行了统计，但需求想要更加明确的统计每个user单独的代码量，以便对该user的工作质量进行评估。sonar目前只有对整个目录文件的代码行数统计，对于git merge之类的代码没有区别得很细，也就是说不断merge别人的代码也会被统计到当前提交的user上，而我们是需要明确每个user具体提交了多少代码量，然后下面是针对有效代码行数预研的方案及试错，有需要的朋友可以参阅，少走弯路。 已实现:提交通过的代码可以用sonar统计行数。Num2-Num1=有效行数（实际开发行数）存在问题：如果过程中分支有从别的分支合并代码过来，会造成统计时混合了其他分支代码。 处理方案方案一：（客户端方案）1.情况一，当前功能分支一直提交，并没有merge其他分支来支持当前分支开发，那么可以通过每次提交成功后统计该分支的有效行数，通过之前已实现的sonar方案。2.情况二，f2分支在开发过程中，如需要引用f1分支的功能作为开发支撑，这种情况需要在客户端的git仓库中埋点，使用git hook（post-merge）监听，当pull f1并merge成功后，触发post-merge监听，接着执行通知，告知接收者几个关键参数（合并的分支、合并成功后总代码行数），接收者收到入参后，接着统计合并分支的代码行数，然后 合并后的总行数-当前统计分支行数=合并进来的行数，以后每次f1分支提交统计代码行数时，都减去“合并进来的行数”得到提交的有效行数。 方案二：（服务端方案）拉取分支后，云效在未合并完成前，不允许拉取合并其他分支。监听用户的在服务端的post-receive触发，如果与第一次拉取做一个对应关系。 方案三：（本地客户端hook，优化版本）本地客户端方案关键点：hook脚本注入，本地代码统计方案，merge、commit触发执行脚本，shell脚本post交互（实现全局hook，本质也是本地配置引用，需要配置干预。与直接copy都是需要人为本地干预 no）1.hook脚本注入：hook文件自动copy暂时没有触发入口（方案：云效流程干预）2.shell脚本post交互：云效上有sonar数据的拦截处理层，这部分之前是我们自己处理，api交互补充逻辑即可。方案步骤：1.拉取分支，然后给一个勾选的触发，弹窗，选择远程的hook和本地仓库目录（目录/.git/hooks）在云效这里，由于客户端pull动作无法知道完成时机，要么云效定时循环检测目录存在，然后注入远程hook，要么培训说明人为判断拉取成功后必须手动勾选，然后注入远程hook，两个方式目的都是想办法把远程的hooks文件注入到本地的hooks目录中。2.本地代码统计（难点，在不安转三方支持的情况下，怎么统计分支除merge之外的纯代码量，暂时只统计新增行）那么考虑能否从文件本身的角度入手，监听或合适时机主动获取文件数量和文件总行数。把过程中产生纯新增行数记录到并合适时机告诉接收者。3.shell通过curl发送post请求：curl -d parm1=111&amp;param2=222 http://www.baidu.com4.本地每次merge与本地commit只有hook存在，都能触发对应的脚本程序。 实验情况：1.测试本地存在hook脚本的情况，在本地分支merge和commit两个关键动作都能触发执行脚本。本地提交，成功触发pre-commit脚本：本地分支merge，成功触发post-merge脚本： 2.测试目录文件数及总行数：获取本地仓库目录下，所有文件书和行数：shell脚本测试ok补充：1）能否去除空行，注释行。（使用grep排除空行和注释行，sed和tee用法）2）缓存对比数据方案（本地？远程？）3）test.sh在统计文件数和行数，不包括.git目录的。执行结果：3.测试修改文件了，先merge再commit，确定行数获取时机。答：merge之前，git的操作是必须需要先本地commit当前分支，否则合并失败。（保证当前分支是最新的节点）这里就解决了，统计merge之前和merge之后的代码行数。统一由commit时产生的行数作为计算基准数。当前分支未commit就执行merge动作：当前分支已commit，执行merge动作，触发脚本计算行数： 方案四：服务器端，分析.git，分离每个user提交的代码信息，分别获取对应的行数。（选用方案）脚本代码：统计总行数、历史删除、增加的总行数1git log --author=&quot;hans&quot; --pretty=tformat: --numstat | gawk &apos;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;增加的行数:%s 删除的行数:%s 总行数: %s\n&quot;,add,subs,loc &#125;&apos; 注意：该方法统计，最后一行如果是空行，不纳入行数计算，如果不是则纳入。测试场景：用户hans：1.master分支有10行，在master上创建分支t1，t1分支新增5行。分别获取master行数、t1行数master行数10：t1行数15： 2.上传t1分支，让用户tt克隆项目，tt用户在master的基础上新建分支t2，新增行数8，提交。分别获取hans提交行数，tt提交行数。把t2合并进入master，再次统计master上不同用户提交的代码行数，hans行数10，tt行数8，符合预期有效行数。补充：hans电脑上传master（已合并t2），下图是tt电脑上，拉取最新的master，然后再次分别获取对应行数。对于tt用户来说，虽然master上行数变为18行，但统计tt的提交量还是8行，符合预期有效行数。3.测试同一个文件下，不同用户操作，并统计行数。在hans电脑上，如果发生冲突的部分，会导致tt用户提交的这部分冲突代码统计失败，还是原来的8行，只有hans的代码新增了，由原来的10行，新增了5行。在tt用户电脑，master上pull回来，统计同hans电脑结果。 结论：1.为了统计用户有效代码行数，建议每个用户在commit的行都是新的行，如果在别的用户行上修改，统计时是不纳入你的代码行数。2.每个分支上，用户之间提交的代码行数都是相互隔离的，可以分别获取对应用户提交的代码行数，与merge无关。3.在实际应用上，虽然shell脚本已经编写完毕，但是由于系统间在执行过程中会存在权限问题，不保证每个系统都稳定能执行到脚本。最终讨论的方案是，通过Java调用git命令来执行git的信息统计，后面会针对该内容专门开一篇文章分享。 相关资料git hooks钩子：那么钩子什么时候被执行，Git预定义了触发时机：ClientSide hooks：1 pre-commit，当执行commit动作时先执行此hook，可以用此hook做一些检查，比如代码风格检查，或者先跑测试。2 prepare-commit-msg， 当commit时需要输入message前会触发此hook，可以用此hook来定制自己的default message信息。3 commit-msg，当用户输入commit的message后被触发，可以用此hook校验message的信息，比如是否符合规定，有没有cr等。4 post-commit, 当commit完成后被触发，可以用此hook发送notification等。5 pre-rebase, rebase之前会被触发，可以用此hook来拒绝所有的已经push的commits进行rebase操作。6 post-merge, 当merge成功后，会触发此hook。7 pre-push, 当push时，remote refs被更新，但是在所有的objects传输前被触发。8 pre-auto-gc, 当git gc –auto执行前被触发。在垃圾回收之前做一些验证或备份是挺不错的。 ServerSide hooks:1 pre-receive, 当收到push动作之前会被执行。2 update, 也是收到push动作之前被执行，但是有可能被执行多次，每个branch一次。3 post-receive, 当push动作已经完成的时候会被触发，可以用此hook来push notification等，比如发邮件，通知持续构建服务器等。 git log相关信息：统计某人的代码提交量，包括增加，删除：git log –author=”$(git config –get user.name)” –pretty=tformat: –numstat | gawk ‘{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf “added lines: %s removed lines : %s total lines: %s\n”,add,subs,loc }’ -仓库提交者排名前 5（如果看全部，去掉 head 管道即可）：git log –pretty=’%aN’ | sort | uniq -c | sort -k1 -n -r | head -n 5仓库提交者（邮箱）排名前 5：这个统计可能不会太准，因为很多人有不同的邮箱，但会使用相同的名字git log –pretty=format:%ae | gawk – ‘{ ++c[$0]; } END { for(cc in c) printf “%5d %s\n”,c[cc],cc; }’ | sort -u -n -r | head -n 5贡献者统计：git log –pretty=’%aN’ | sort -u | wc -l提交数统计：git log –oneline | wc -l添加或修改的代码行数：git log –stat|perl -ne ‘END { print $c } $c += $1 if /(\d+) insertions/; git log 参数说明：–author 指定作者–stat 显示每次更新的文件修改统计信息，会列出具体文件列表–shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：–numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 例如：git log -p -2–name-only 仅在提交信息后显示已修改的文件清单–name-status 显示新增、修改、删除的文件清单–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）–graph 显示 ASCII 图形表示的分支合并历史–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式） 例如： git log –pretty=oneline ; git log –pretty=short ; git log –pretty=full ; git log –pretty=fuller–pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析 例如：git log –pretty=format:””%h - %an, %ar : %s”” 下面列出了常用的格式占位符写法及其代表的意义。 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明–since 限制显示输出的范围， 例如： git log –since=2.weeks 显示最近两周的提交 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 一些例子： // 一分钟之前的所有 git log --until=1.minute.ago //一天之内的log log git log --since=1.day.ago //一个小时之内的log git log --since=1.hour.ago //一个月之前到半个月之前的log git log --since=`.month.ago --until=2.weeks.ago //某个时间段的log git log --since ==2013-08.01 --until=2013-09-07 //看看某一个文件的相关历史记录 git blame 例如：git blame index.html --date short]]></content>
      <categories>
        <category>方案</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题的个性化设置及评论系统的集成]]></title>
    <url>%2F2018%2F09%2F17%2FHexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[前言这篇文章是续&lt;玩Hexo博客，从搭建到百度、谷歌收录全流程&gt;的补充篇，该篇文章主要描述的是Hexo在实际的配置过程中，需要设置的点。以本博客为案例，一步步配置自己喜欢的Hexo显示。 正文修改或新增菜单打开themes/next/_config.yml 文件，搜索menu关键字，修改对应图标名称或者新增对应menu的图标。123456789101112131415menu: #首页 default home: / || home #归档 default archives: /archives/ || archive #分类 categories: /categories/ || th #标签 tags: /tags/ || tags #相册 photo_album: /photo_album/ || image #友链 friendly_link: /friendly_link/ || link #关于 about: /about/ || user 注意：1.除了home，archives , /后面都需要手动创建这个页面。2.图片对应的名称，例如link图标，可以在hexo个性化icon网站 找到。 添加头像打开 themes/next/_config.yml文件，搜索Sidebar Avatar关键字，去掉avatar 前面的#，并补充自己的头像路径。注意：头像存放路径\themes\next\source\uploads，uploads文件夹如果没有则新建，然后存放头像图片即可读取。1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/hans_icon.jpg 上下浏览当前页面时显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。12# Scroll percent label in b2t button scrollpercent: true 如果想把 top按钮放在侧边栏,打开 themes/next/_config.yml ,搜索关键字 b2t ,把 false 改为 true。12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 设置侧边栏社交链接打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。其中，图标可以根据上面菜单图标的方式替换。123456#社交连接social: GitHub: https://huangweicai.github.io/ || github 简书: https://www.jianshu.com/u/28a4d1accff3 || book Coding: http://lantianwork.coding.me/ || codiepie 知乎: https://www.zhihu.com/people/wei-c-77-91/activities || certificate 开启版权声明主题配置文件下,搜索关键字 post_copyright , enable 改为 true：12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 添加顶部加载条打开 themes/next/_config.yml ，搜索关键字 pace ,设置为 true ,可以更换加载样式：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash #替换更换样式 其他的可以参考该文章:Hexo+Next个人博客主题优化]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客，从搭建到百度、谷歌收录全流程]]></title>
    <url>%2F2018%2F09%2F17%2FHexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%BB%8E%E6%90%AD%E5%BB%BA%E5%88%B0%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言hexo静态博客很早就耳闻了，鉴于时间和精力，之前一直没决心要做一个自己的个人网站。在使用hexo搭建静态博客之前，还有一个小插曲，之前曾经考虑过使用wordpress搭建个人网站，阿里云服务器和域名都已经购买，并且已经在服务器上配置好了相关内容，但是域名备案需要服务器运行3个月，只能通过ip地址访问wordpress博客，这个点就很影响个人网站的使用，并且阿里云服务器一年的费用达到2000多，也是一笔不小的开销。综合权衡对比之后，转而投向谷歌github、百度coding的hexo静态个人网站，好处是免费并且有平台提供的特定域名地址，并且hexo可以满足目前这些所有的需要，个性化定制型强，搭配目前使用人数最多的next主题，简直是帅到不要。并且现在很多搜索到的个人博客，基本都是hexo+next主题的搭配，可见其受欢迎程度。言归正传，下面就把玩hexo从搭建到收录全过程分享给大家，很多坑点网上是找不到的，千篇一律的内容很难分析问题。 相关资料1.关键地址NexT主题官方文档 hexo的一些部署配置可以简单参看，主要看NexT主题怎么在hexo中配置，定制个性化内容。leancloud网站 博客集成阅读数，valine评论系统都需要用到。hexo个性化icon网站 里面的icon名称可以使用到hexo中，替换并定制化icon，hexo的图标都是关联到这里的。coding网站 国内存放静态博客界面代码github网站 国外存放静态博客界面代码注意：个人把静态博客分别上传到coding、github，方便国内和国外的搜索引擎爬取到内容。自己可以酌情选用。百度收录站点 提交coding域名谷歌收录站点 提交github域名 2.相关地址valine评论系统用于博客集成评论系统Node.js hexo需要先安装node.js环境Git hexo在上传时需要用到git5.1: git@github.com:iissnan/hexo-theme-next.git （个人使用版本）6.0: git@github.com:theme-next/hexo-theme-next.git 正文3.准备工作本地环境需要安装Node.js和Git，可以在上面的地址找到安装下载界面。 4.安装并初始化hexo上面两个准备工作完成后，可以选择一个目录，右键选择Git Bash Here打开终端，依次执行如下命令：（使用cmd的终端也行，不过需要配置git的环境变量，这里直接使用git自带的终端方便）1234npm install -g hexo-clihexo init Hexocd Hexonpm install 都执行成功后，会在目录生成一个Hexo文件夹，以后Hexo文件夹就是本地静态网站配合和文章存放的地方。接下来启动本地hexo，先本地预览hexo，执行如下命令：1hexo s 当看到命令行窗口出现，INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.的内容时，说明启动成功了，然后在浏览器输入网址：http://localhost:4000/ 即可看到本地hexo网站了。 另外，补充几个hexo关键的操作命令：1234hexo clean #清空hexo，主要删除Hexo根目录下的public文件夹hexo g #重新成功public文件夹内容hexo s #启动本地hexo服务hexo d #发布到远程仓库 以后每次同步远程仓库，基本都是上面的命令顺序。 5.替换默认的hexo主题（landscape–&gt;NexT）hexo默认的主题是landscape，目前NexT主题是使用最多的，个性化定制性都很好，使用NexT主题替换landscape默认主题，我们需要先把NexT主题拷贝到Hexo本地，在终端输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 拷贝成功后，使用编辑器打开Hexo根目录下的_config.yml文件，把里面的landscape主题替换成next主题，然后hexo clean，hexo g，hexo s，接着刷新浏览器就可以看到新配置的NexT主题了。1234567891011121314151617181920# Sitetitle: Hexo # 此处改为你站点的标题subtitle: # 此处改为你站点的副标题description: # 此处改为你站点的说明keywords: # 此处改为你站点的关键字author: John Doe # 此处改为你的名字language: # 此处改为 zh-CNtimezone: # 此处改为 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/ # 此处可以改为 :title/permalink_defaults:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 此处改为 next 6.上传本地博客到github或者coding把本地静态代码上传到远程仓库，如github、coding等。首先我们需要在两个平台上有账号，并且分别创建项目仓库，注意，新建的项目名称是有特定要求的，github上的名称必须是：{user_name}.github.io，coding上的名称必须是：{user_name}.coding.me，这样子上传到远程仓库的静态文件，在访问的时候才不会出现样式混乱和404问题，每个平台只提供一个这样的pages页面，而格式也是固定的，按照人家平台的规定来就行了。其中，用户名就是当时注册的时候用的是那个名称，别搞乱了，不是后面修改资料的昵称，用户名一般修改不了。 上传之前，先把ssh在本地配置一下，打开Hexo根目录下的_config.yml文件，找到deploy并如下修改：（把其中的github和coding的ssh替换成自己的就行了，注意一下，需要先在平台上配置好publickey，玩git的应该都知道）12345deploy: type: git repo: github: git@github.com:xxx/xxx.github.io.git,master coding: git@git.coding.net:xxx/xxx.coding.me.git,master 修改好了之后，执行命令，上传到远程仓库：1hexo g -d 最后，浏览器打开远程仓库地址，查看代码，然后分别把github或coding的pages打开，等待一会，然后访问pages地址就可以看到你提交的个人网站了。 7.百度、谷歌收录操作让百度、谷歌收录个人网站，需要两个平台上的验证文件放在博客的根目录下（这里选择推荐的一种验证方式）。打开上面提到的百度收录，谷歌收录的网址，统一选择文件验证的方式，百度这边的话在添加地址的时候，第一次可能需要填写个人信息，补充完毕后，添加网站，然后根据提示下一步操作即可，谷歌的也是类似。这里提一个坑点：百度、谷歌的验证方式都是使用文件验证，从平台上下载的验证文件在放根目录的说法中，网上大多数的说法都是说直接把文件放到Hexo根目录的source目录下，然后上传到远程仓库，但是实验证明这种做法是有问题的，当我们执行hexo g生成静态界面的时候，hexo会把多余的内容添加到source目录下的验证文件中，导致百度或者谷歌验证一直失败。解决方法：在hexo g操作之前，验证文件先不加入到source目录中，等待hexo g执行成功后，手动把验证文件copy到Hexo根目录下的public目录中，然后执行hexo d上传到远程仓库，最后再测试平台上的验证文件，可以看到百度、谷歌都验证成功了。最后就等待收录通过后，输入site:地址，测试一下是否搜索到博客地址。谷歌的收录速度很快，上传到仓库后几个小时就可以搜索到我的网站了，而百度则慢点，可能要一两个星期，有备案填入在百度上则会加快收录速度。 结语上面就是Hexo网站从配置到谷歌、百度收录的全过程了，另外关于Hexo的个性化配置，评论系统的配置等这些还是有很多细节和坑点，可以持续关注，晚些时间会放出关于hexo主题个性化定制的相关内容。可以以本博客显示作为参考。最后，如果在搭建hexo博客过程中，有解决不了的问题或者想让熟悉的人快速帮你配置并指导，可以添加wechat596有偿服务，添加好友时备注：昵称-hexo服务。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
